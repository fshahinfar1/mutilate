!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADAPTIVESAMPLER_H	AdaptiveSampler.h	4;"	d
ADDITIONAL_ERROR	cmdline.cc	2007;"	d	file:
AGENTSTATS_H	AgentStats.h	3;"	d
ARG_FLAG	cmdline.cc	/^  , ARG_FLAG$/;"	e	enum:__anon5	file:
ARG_FLOAT	cmdline.cc	/^  , ARG_FLOAT$/;"	e	enum:__anon5	file:
ARG_INT	cmdline.cc	/^  , ARG_INT$/;"	e	enum:__anon5	file:
ARG_NO	cmdline.cc	/^typedef enum {ARG_NO$/;"	e	enum:__anon5	file:
ARG_STRING	cmdline.cc	/^  , ARG_STRING$/;"	e	enum:__anon5	file:
AdaptiveSampler	AdaptiveSampler.h	/^  AdaptiveSampler(int max) :$/;"	f	class:AdaptiveSampler
AdaptiveSampler	AdaptiveSampler.h	/^template <class T> class AdaptiveSampler {$/;"	c
AgentStats	AgentStats.h	/^class AgentStats {$/;"	c
BARRIER_H	barrier.h	2;"	d
BINARY_PROTOCOL_H	binary_protocol.h	2;"	d
Bimodal	Generator.h	/^  Bimodal(double _ratio, double _v1, double _v2) :$/;"	f	class:Bimodal
Bimodal	Generator.h	/^class Bimodal : public Generator {$/;"	c
CLOSE_AND_DIE	log.h	20;"	d
CMDLINE_H	cmdline.h	9;"	d
CMDLINE_PARSER_PACKAGE	cmdline.h	24;"	d
CMDLINE_PARSER_PACKAGE_NAME	cmdline.h	29;"	d
CMDLINE_PARSER_VERSION	cmdline.h	34;"	d
CMD_GET	binary_protocol.h	4;"	d
CMD_SASL	binary_protocol.h	6;"	d
CMD_SET	binary_protocol.h	5;"	d
CONFIG_FILE_LINE_BUFFER_SIZE	cmdline.cc	2009;"	d	file:
CONFIG_FILE_LINE_SIZE	cmdline.cc	2005;"	d	file:
CONFIG_H_SEEN	config.h	2;"	d
CONNECTIONOPTIONS_H	ConnectionOptions.h	2;"	d
CONNECTIONSTATS_H	ConnectionStats.h	3;"	d
Connection	Connection.h	/^  Connection(bool sampling) : stats(sampling) { };$/;"	f	class:Connection
Connection	Connection.h	/^class Connection {$/;"	c
ConnectionStats	ConnectionStats.h	/^ ConnectionStats(bool _sampling = true) :$/;"	f	class:ConnectionStats
ConnectionStats	ConnectionStats.h	/^class ConnectionStats {$/;"	c
CustomKeyGenerator	Generator.h	/^  CustomKeyGenerator(Generator* t, Generator* r) : comp_time(t), val_size(r) {}$/;"	f	class:CustomKeyGenerator
CustomKeyGenerator	Generator.h	/^class CustomKeyGenerator {$/;"	c
D	log.h	11;"	d
DEBUG	log.h	/^enum log_level_t { DEBUG, VERBOSE, INFO, WARN, QUIET };$/;"	e	enum:log_level_t
DIE	log.h	16;"	d
DISTRIBUTIONS_H	distributions.h	2;"	d
DPDKConnection	DPDKConnection.cc	/^DPDKConnection::DPDKConnection(string hostname, int port, options_t options, bool sampling) :$/;"	f	class:DPDKConnection
DPDKConnection	DPDKConnection.h	/^class DPDKConnection : public Connection {$/;"	c
Discrete	Generator.h	/^  Discrete(Generator* _def = NULL) : def(_def) {$/;"	f	class:Discrete
Discrete	Generator.h	/^class Discrete : public Generator {$/;"	c
ETHER_TYPE_IPv4	dpdktcp.c	16;"	d	file:
EXPONENTIAL	distributions.h	/^enum distribution_t { UNIFORM, EXPONENTIAL, ZIPFIAN, LATEST };$/;"	e	enum:distribution_t
Exponential	Generator.h	/^  Exponential(double _lambda = 1.0) : lambda(_lambda) {$/;"	f	class:Exponential
Exponential	Generator.h	/^class Exponential : public Generator {$/;"	c
FIX_UNUSED	cmdline.cc	21;"	d	file:
FNV1_64_INIT	util.cc	14;"	d	file:
FNV_64_PRIME	util.cc	13;"	d	file:
FileGenerator	Generator.h	/^  FileGenerator(const char *filename) {$/;"	f	class:FileGenerator
FileGenerator	Generator.h	/^class FileGenerator : public Generator {$/;"	c
Fixed	Generator.h	/^  Fixed(double _value = 1.0) : value(_value) { D("Fixed(%f)", value); }$/;"	f	class:Fixed
Fixed	Generator.h	/^class Fixed : public Generator {$/;"	c
GENERATOR_H	Generator.h	8;"	d
GET	Operation.h	/^    GET, SET, SASL$/;"	e	enum:Operation::type_enum
GEV	Generator.h	/^  GEV(double _loc = 0.0, double _scale = 1.0, double _shape = 1.0) :$/;"	f	class:GEV
GEV	Generator.h	/^class GEV : public Generator {$/;"	c
GPareto	Generator.h	/^  GPareto(double _loc = 0.0, double _scale = 1.0, double _shape = 1.0) :$/;"	f	class:GPareto
GPareto	Generator.h	/^class GPareto : public Generator {$/;"	c
Generator	Generator.h	/^  Generator() {}$/;"	f	class:Generator
Generator	Generator.h	/^class Generator {$/;"	c
HAVE_DECL_EVENT_BASE_FLAG_PRECISE_TIMER	config.h	10;"	d
HAVE_LIBEVENT	config.h	7;"	d
HAVE_LIBPTHREAD	config.h	13;"	d
HAVE_LIBRT	config.h	16;"	d
HAVE_LIBZMQ	config.h	19;"	d
HAVE_PTHREAD_BARRIER_INIT	config.h	22;"	d
HISTOGRAMSAMPLER_H	HistogramSampler.h	3;"	d
HistogramSampler	HistogramSampler.h	/^  HistogramSampler(int _bins, int _width) : overflow_sum(0.0) {$/;"	f	class:HistogramSampler
HistogramSampler	HistogramSampler.h	/^class HistogramSampler {$/;"	c
I	log.h	13;"	d
IDLE	Connection.h	/^    IDLE,$/;"	e	enum:Connection::read_state_enum
INFO	log.h	/^enum log_level_t { DEBUG, VERBOSE, INFO, WARN, QUIET };$/;"	e	enum:log_level_t
INIT_READ	Connection.h	/^    INIT_READ,$/;"	e	enum:Connection::read_state_enum
INIT_WRITE	Connection.h	/^    INIT_WRITE,$/;"	e	enum:Connection::write_state_enum
IP4	dpdktcp.h	3;"	d
IPPROTO_TCP	dpdktcp.c	17;"	d	file:
ISSUING	Connection.h	/^    ISSUING,$/;"	e	enum:Connection::write_state_enum
KeyGenerator	Generator.h	/^  KeyGenerator(Generator* _g, double _max = 10000) : g(_g), max(_max) {}$/;"	f	class:KeyGenerator
KeyGenerator	Generator.h	/^class KeyGenerator {$/;"	c
L	log.h	9;"	d
LATEST	distributions.h	/^enum distribution_t { UNIFORM, EXPONENTIAL, ZIPFIAN, LATEST };$/;"	e	enum:distribution_t
LOADER_CHUNK	mutilate.h	12;"	d
LOADING	Connection.h	/^    LOADING,$/;"	e	enum:Connection::read_state_enum
LOGHISTOGRAMSAMPLER_H	LogHistogramSampler.h	3;"	d
LOG_H	log.h	2;"	d
LogHistogramSampler	LogHistogramSampler.h	/^  LogHistogramSampler(int _bins) : sum(0.0), sum_sq(0.0) {$/;"	f	class:LogHistogramSampler
LogHistogramSampler	LogHistogramSampler.h	/^class LogHistogramSampler {$/;"	c
LogNormal	Generator.h	/^  LogNormal(double _mu, double _sigma) :$/;"	f	class:LogNormal
LogNormal	Generator.h	/^class LogNormal : public Generator {$/;"	c
MAX	Generator.h	10;"	d
MAXIMUM_CONNECTIONS	mutilate.h	8;"	d
MAX_CONNECTIONS	dpdktcp.c	27;"	d	file:
MAX_READ_STATE	Connection.h	/^    MAX_READ_STATE,$/;"	e	enum:Connection::read_state_enum
MAX_SAMPLES	mutilate.h	10;"	d
MAX_TCP_PAYLOAD	dpdktcp.c	28;"	d	file:
MAX_WRITE_STATE	Connection.h	/^    MAX_WRITE_STATE,$/;"	e	enum:Connection::write_state_enum
MBUF_CACHE_SIZE	dpdktcp.c	14;"	d	file:
MIN	Generator.h	11;"	d
MIN	mutilate.cc	42;"	d	file:
MINIMUM_KEY_LENGTH	mutilate.h	7;"	d
MUTILATE_H	mutilate.h	2;"	d
NOLOG	log.h	22;"	d
NONE	ConnectionOptions.h	/^  NONE,$/;"	e	enum:qps_function_type
NUM_MBUFS	dpdktcp.c	13;"	d	file:
Normal	Generator.h	/^  Normal(double _mean = 1.0, double _sd = 1.0) : mean(_mean), sd(_sd) {$/;"	f	class:Normal
Normal	Generator.h	/^class Normal : public Generator {$/;"	c
OPERATION_H	Operation.h	3;"	d
OpQueue	UDPConnection.h	/^class OpQueue {$/;"	c
Operation	Operation.h	/^class Operation {$/;"	c
QTRIANGLE	ConnectionOptions.h	/^  QTRIANGLE,$/;"	e	enum:qps_function_type
QUIET	log.h	/^enum log_level_t { DEBUG, VERBOSE, INFO, WARN, QUIET };$/;"	e	enum:log_level_t
RESP_OK	binary_protocol.h	8;"	d
RESP_SASL_ERR	binary_protocol.h	9;"	d
RETRANSMIT_INTERVAL	UDPConnection.cc	15;"	d	file:
RX_RING_SIZE	dpdktcp.c	11;"	d	file:
Runner	ez_mutilate.py	/^class Runner:$/;"	c
SASL	Operation.h	/^    GET, SET, SASL$/;"	e	enum:Operation::type_enum
SCAN_SEARCH_CTX	common.h	/^    SCAN_SEARCH_CTX,$/;"	e	enum:agent_stats_msg::type
SET	Operation.h	/^    GET, SET, SASL$/;"	e	enum:Operation::type_enum
SIN_NOISE	ConnectionOptions.h	/^  SIN_NOISE,$/;"	e	enum:qps_function_type
STATS	common.h	/^    STATS,$/;"	e	enum:agent_stats_msg::type
STOP	common.h	/^    STOP,$/;"	e	enum:agent_stats_msg::type
TCPConnection	TCPConnection.cc	/^TCPConnection::TCPConnection(struct event_base* _base, struct evdns_base* _evdns,$/;"	f	class:TCPConnection
TCPConnection	TCPConnection.h	/^class TCPConnection : public Connection {$/;"	c
TCP_ACK	dpdktcp.c	22;"	d	file:
TCP_CLOSED	dpdktcp.c	/^		TCP_CLOSED,$/;"	e	enum:pcb::__anon7	file:
TCP_CWR	dpdktcp.c	25;"	d	file:
TCP_ECE	dpdktcp.c	24;"	d	file:
TCP_ESTABLISHED	dpdktcp.c	/^		TCP_ESTABLISHED$/;"	e	enum:pcb::__anon7	file:
TCP_FIN	dpdktcp.c	18;"	d	file:
TCP_PSH	dpdktcp.c	21;"	d	file:
TCP_RST	dpdktcp.c	20;"	d	file:
TCP_SYN	dpdktcp.c	19;"	d	file:
TCP_URG	dpdktcp.c	23;"	d	file:
TRIANGLE	ConnectionOptions.h	/^  TRIANGLE,$/;"	e	enum:qps_function_type
TX_RING_SIZE	dpdktcp.c	12;"	d	file:
UDPConnection	UDPConnection.cc	/^UDPConnection::UDPConnection(struct event_base* base, string hostname, int port, options_t options, bool sampling) :$/;"	f	class:UDPConnection
UDPConnection	UDPConnection.h	/^class UDPConnection : public Connection {$/;"	c
UNIFORM	distributions.h	/^enum distribution_t { UNIFORM, EXPONENTIAL, ZIPFIAN, LATEST };$/;"	e	enum:distribution_t
USE_CACHED_TIME	mutilate.h	6;"	d
UTIL_H	util.h	2;"	d
Uniform	Generator.h	/^  Uniform(double _scale) : scale(_scale) { D("Uniform(%f)", scale); }$/;"	f	class:Uniform
Uniform	Generator.h	/^class Uniform : public Generator {$/;"	c
V	log.h	12;"	d
VERBOSE	log.h	/^enum log_level_t { DEBUG, VERBOSE, INFO, WARN, QUIET };$/;"	e	enum:log_level_t
W	log.h	14;"	d
WAITING_FOR_END	Connection.h	/^    WAITING_FOR_END,$/;"	e	enum:Connection::read_state_enum
WAITING_FOR_GET	Connection.h	/^    WAITING_FOR_GET,$/;"	e	enum:Connection::read_state_enum
WAITING_FOR_GET_DATA	Connection.h	/^    WAITING_FOR_GET_DATA,$/;"	e	enum:Connection::read_state_enum
WAITING_FOR_OPQ	Connection.h	/^    WAITING_FOR_OPQ,$/;"	e	enum:Connection::write_state_enum
WAITING_FOR_SASL	Connection.h	/^    WAITING_FOR_SASL,$/;"	e	enum:Connection::read_state_enum
WAITING_FOR_SET	Connection.h	/^    WAITING_FOR_SET,$/;"	e	enum:Connection::read_state_enum
WAITING_FOR_TIME	Connection.h	/^    WAITING_FOR_TIME,$/;"	e	enum:Connection::write_state_enum
WARN	log.h	/^enum log_level_t { DEBUG, VERBOSE, INFO, WARN, QUIET };$/;"	e	enum:log_level_t
ZIPFIAN	distributions.h	/^enum distribution_t { UNIFORM, EXPONENTIAL, ZIPFIAN, LATEST };$/;"	e	enum:distribution_t
Zipf	Generator.h	/^  Zipf(int _n, double _theta, long permutation_seed) : n(_n), theta(_theta) {$/;"	f	class:Zipf
Zipf	Generator.h	/^class Zipf : public Generator {$/;"	c
_POW	LogHistogramSampler.h	15;"	d
__STDC_FORMAT_MACROS	config.h	4;"	d
__enter__	ez_mutilate.py	/^  def __enter__(self):$/;"	m	class:Runner	file:
__exit__	ez_mutilate.py	/^  def __exit__(self, type, value, traceback):$/;"	m	class:Runner	file:
__init__	ez_mutilate.py	/^  def __init__(self):$/;"	m	class:Runner
__tcp_send	dpdktcp.c	/^static void __tcp_send(struct pcb *pcb, const void *data, size_t len)$/;"	f	file:
_cmdline_parser_configfile	cmdline.cc	/^_cmdline_parser_configfile (const char *filename, int *my_argc)$/;"	f	file:
_createPopularityGenerator	Generator.cc	/^static Generator *_createPopularityGenerator(std::string str, long records, long permutation_seed) {$/;"	f	file:
accumulate	ConnectionStats.h	/^  void accumulate(const AgentStats &as) {$/;"	f	class:ConnectionStats
accumulate	ConnectionStats.h	/^  void accumulate(const ConnectionStats &cs) {$/;"	f	class:ConnectionStats
accumulate	HistogramSampler.h	/^  void accumulate(const HistogramSampler &h) {$/;"	f	class:HistogramSampler
accumulate	LogHistogramSampler.h	/^  void accumulate(const LogHistogramSampler &h) {$/;"	f	class:LogHistogramSampler
acked	dpdktcp.c	/^	uint32_t acked;$/;"	m	struct:pcb	file:
add	Generator.h	/^  void add(double p, double v) {$/;"	f	class:Discrete
add_node	cmdline.cc	/^static void add_node(struct generic_list **list) {$/;"	f	file:
affinity_given	cmdline.h	/^  unsigned int affinity_given ;	\/**< @brief Whether affinity was given.  *\/$/;"	m	struct:gengetopt_args_info
affinity_help	cmdline.h	/^  const char *affinity_help; \/**< @brief Set CPU affinity for threads, round-robin help description.  *\/$/;"	m	struct:gengetopt_args_info
agent	mutilate.cc	/^void agent() {$/;"	f
agent	mutilateudp.cc	/^static void agent(void)$/;"	f	file:
agent_arg	cmdline.h	/^  char ** agent_arg;	\/**< @brief Enlist remote agent..  *\/$/;"	m	struct:gengetopt_args_info
agent_given	cmdline.h	/^  unsigned int agent_given ;	\/**< @brief Whether agent was given.  *\/$/;"	m	struct:gengetopt_args_info
agent_help	cmdline.h	/^  const char *agent_help; \/**< @brief Enlist remote agent. help description.  *\/$/;"	m	struct:gengetopt_args_info
agent_max	cmdline.h	/^  unsigned int agent_max; \/**< @brief Enlist remote agent.'s maximum occurreces *\/$/;"	m	struct:gengetopt_args_info
agent_min	cmdline.h	/^  unsigned int agent_min; \/**< @brief Enlist remote agent.'s minimum occurreces *\/$/;"	m	struct:gengetopt_args_info
agent_orig	cmdline.h	/^  char ** agent_orig;	\/**< @brief Enlist remote agent. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
agent_port_arg	cmdline.h	/^  char * agent_port_arg;	\/**< @brief Agent port. (default='5556').  *\/$/;"	m	struct:gengetopt_args_info
agent_port_given	cmdline.h	/^  unsigned int agent_port_given ;	\/**< @brief Whether agent_port was given.  *\/$/;"	m	struct:gengetopt_args_info
agent_port_help	cmdline.h	/^  const char *agent_port_help; \/**< @brief Agent port. help description.  *\/$/;"	m	struct:gengetopt_args_info
agent_port_orig	cmdline.h	/^  char * agent_port_orig;	\/**< @brief Agent port. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
agent_sampling_flag	cmdline.h	/^  int agent_sampling_flag;	\/**< @brief each agent will sample connection stats and if `save` argument has been given it is also is applied to agents (default=off).  *\/$/;"	m	struct:gengetopt_args_info
agent_sampling_given	cmdline.h	/^  unsigned int agent_sampling_given ;	\/**< @brief Whether agent-sampling was given.  *\/$/;"	m	struct:gengetopt_args_info
agent_sampling_help	cmdline.h	/^  const char *agent_sampling_help; \/**< @brief each agent will sample connection stats and if `save` argument has been given it is also is applied to agents help description.  *\/$/;"	m	struct:gengetopt_args_info
agent_sockets	mutilate.cc	/^vector<zmq::socket_t*> agent_sockets;$/;"	v
agent_sockets	mutilatedpdk.cc	/^vector<zmq::socket_t*> agent_sockets;$/;"	v
agent_sockets	mutilateudp.cc	/^vector<zmq::socket_t*> agent_sockets;$/;"	v
agent_stats_msg	common.h	/^struct agent_stats_msg {$/;"	s
agent_stats_thread	common.cc	/^void* agent_stats_thread(void *arg) {$/;"	f
agent_stats_thread_data	common.h	/^struct agent_stats_thread_data {$/;"	s
agent_stats_tx_scan_search_ctx	mutilate.cc	/^static bool agent_stats_tx_scan_search_ctx(zmq::socket_t *s, struct scan_search_ctx *scan_search_ctx) {$/;"	f	file:
agent_stats_tx_stats	common.cc	/^bool agent_stats_tx_stats(zmq::socket_t *s) {$/;"	f
agent_stats_tx_stop	common.cc	/^static bool agent_stats_tx_stop(zmq::socket_t *s) {$/;"	f	file:
agent_thread	mutilateudp.cc	/^static void *agent_thread(void *arg)$/;"	f	file:
agentmode_given	cmdline.h	/^  unsigned int agentmode_given ;	\/**< @brief Whether agentmode was given.  *\/$/;"	m	struct:gengetopt_args_info
agentmode_help	cmdline.h	/^  const char *agentmode_help; \/**< @brief Run client in agent mode. help description.  *\/$/;"	m	struct:gengetopt_args_info
all_connections	mutilate.cc	/^vector<Connection*> all_connections;$/;"	v
all_connections	mutilatedpdk.cc	/^vector<Connection*> all_connections;$/;"	v
all_connections	mutilateudp.cc	/^vector<Connection*> all_connections;$/;"	v
all_connections_mutex	mutilate.cc	/^pthread_mutex_t all_connections_mutex;$/;"	v
all_connections_mutex	mutilateudp.cc	/^static pthread_mutex_t all_connections_mutex;$/;"	v	file:
alpha	Generator.h	/^  double alpha;$/;"	m	class:Zipf
arg	cmdline.cc	/^  union generic_value arg;$/;"	m	struct:generic_list	typeref:union:generic_list::generic_value	file:
arg	dpdktcp.c	/^	void *arg;$/;"	m	struct:pcb	file:
args	mutilatedpdk.cc	/^gengetopt_args_info args;$/;"	v
args	mutilateudp.cc	/^gengetopt_args_info args;$/;"	v
args_to_options	common.cc	/^void args_to_options(options_t* options) {$/;"	f
assert_cmdline	mutilatedpdk.cc	/^static void assert_cmdline(void)$/;"	f	file:
assert_cmdline	mutilateudp.cc	/^static void assert_cmdline(void)$/;"	f	file:
average	AdaptiveSampler.h	/^  double average() {$/;"	f	class:AdaptiveSampler
average	HistogramSampler.h	/^  double average() {$/;"	f	class:HistogramSampler
average	LogHistogramSampler.h	/^  double average() {$/;"	f	class:LogHistogramSampler
barrier	mutilate.cc	/^pthread_barrier_t barrier;$/;"	v
barrier	mutilateudp.cc	/^static pthread_barrier_t barrier;$/;"	v	file:
barrier_destroy	barrier.cc	/^int barrier_destroy(barrier_t *barrier)$/;"	f
barrier_init	barrier.cc	/^int barrier_init(barrier_t *barrier,int needed)$/;"	f
barrier_t	barrier.h	/^} barrier_t;$/;"	t	typeref:struct:__anon6
barrier_wait	barrier.cc	/^int barrier_wait(barrier_t *barrier)$/;"	f
base	TCPConnection.h	/^  struct event_base *base;$/;"	m	class:TCPConnection	typeref:struct:TCPConnection::event_base
begin	UDPConnection.cc	/^std::list<Operation>::iterator OpQueue::begin()$/;"	f	class:OpQueue
bev	TCPConnection.h	/^  struct bufferevent *bev;$/;"	m	class:TCPConnection	typeref:struct:TCPConnection::bufferevent
bev_event_cb	TCPConnection.cc	/^void bev_event_cb(struct bufferevent *bev, short events, void *ptr) {$/;"	f
bev_read_cb	TCPConnection.cc	/^void bev_read_cb(struct bufferevent *bev, void *ptr) {$/;"	f
bev_write_cb	TCPConnection.cc	/^void bev_write_cb(struct bufferevent *bev, void *ptr) {$/;"	f
binary	ConnectionOptions.h	/^  bool binary;$/;"	m	struct:__anon9
binary_given	cmdline.h	/^  unsigned int binary_given ;	\/**< @brief Whether binary was given.  *\/$/;"	m	struct:gengetopt_args_info
binary_header_t	binary_protocol.h	/^} binary_header_t;$/;"	t	typeref:struct:__anon1
binary_help	cmdline.h	/^  const char *binary_help; \/**< @brief Use binary memcached protocol instead of ASCII. help description.  *\/$/;"	m	struct:gengetopt_args_info
bins	HistogramSampler.h	/^  std::vector<uint64_t> bins;$/;"	m	class:HistogramSampler
bins	LogHistogramSampler.h	/^  std::vector<uint64_t> bins;$/;"	m	class:LogHistogramSampler
blocking	ConnectionOptions.h	/^  bool blocking;$/;"	m	struct:__anon9
blocking_given	cmdline.h	/^  unsigned int blocking_given ;	\/**< @brief Whether blocking was given.  *\/$/;"	m	struct:gengetopt_args_info
blocking_help	cmdline.h	/^  const char *blocking_help; \/**< @brief Use blocking epoll().  May increase latency. help description.  *\/$/;"	m	struct:gengetopt_args_info
body_len	binary_protocol.h	/^  uint32_t body_len;$/;"	m	struct:__anon1
boot_time	mutilate.cc	/^double boot_time;$/;"	v
called	barrier.h	/^    int called;$/;"	m	struct:__anon6
check_ambiguity	cmdline.h	/^  int check_ambiguity; \/**< @brief whether to check for options already specified in the option structure gengetopt_args_info (default 0) *\/$/;"	m	struct:cmdline_parser_params
check_exit_condition	TCPConnection.cc	/^bool TCPConnection::check_exit_condition(double now) {$/;"	f	class:TCPConnection
check_multiple_option_occurrences	cmdline.cc	/^check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc)$/;"	f
check_required	cmdline.h	/^  int check_required; \/**< @brief whether to check that all required options were provided (default 1) *\/$/;"	m	struct:cmdline_parser_params
chksum	dpdktcp.c	/^	uint16_t chksum;$/;"	m	struct:ipv4_hdr	file:
cksum	dpdktcp.c	/^	uint16_t cksum;$/;"	m	struct:tcp_hdr	file:
clear_args	cmdline.cc	/^void clear_args (struct gengetopt_args_info *args_info)$/;"	f	file:
clear_given	cmdline.cc	/^void clear_given (struct gengetopt_args_info *args_info)$/;"	f	file:
close_agent_sockets	common.cc	/^void close_agent_sockets(void) {$/;"	f
cmd_line_list	cmdline.cc	/^static struct line_list *cmd_line_list = 0;$/;"	v	typeref:struct:line_list	file:
cmd_line_list_tmp	cmdline.cc	/^static struct line_list *cmd_line_list_tmp = 0;$/;"	v	typeref:struct:line_list	file:
cmdline_parser	cmdline.cc	/^cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)$/;"	f
cmdline_parser2	cmdline.cc	/^cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)$/;"	f
cmdline_parser_arg_type	cmdline.cc	/^} cmdline_parser_arg_type;$/;"	t	typeref:enum:__anon5	file:
cmdline_parser_config_file	cmdline.cc	/^cmdline_parser_config_file (const char *filename,$/;"	f
cmdline_parser_configfile	cmdline.cc	/^cmdline_parser_configfile ($/;"	f
cmdline_parser_dump	cmdline.cc	/^cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)$/;"	f
cmdline_parser_ext	cmdline.cc	/^cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,$/;"	f
cmdline_parser_file_save	cmdline.cc	/^cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)$/;"	f
cmdline_parser_free	cmdline.cc	/^cmdline_parser_free (struct gengetopt_args_info *args_info)$/;"	f
cmdline_parser_init	cmdline.cc	/^cmdline_parser_init (struct gengetopt_args_info *args_info)$/;"	f
cmdline_parser_internal	cmdline.cc	/^cmdline_parser_internal ($/;"	f
cmdline_parser_params	cmdline.h	/^struct cmdline_parser_params$/;"	s
cmdline_parser_params_create	cmdline.cc	/^cmdline_parser_params_create(void)$/;"	f
cmdline_parser_params_init	cmdline.cc	/^cmdline_parser_params_init(struct cmdline_parser_params *params)$/;"	f
cmdline_parser_print_help	cmdline.cc	/^cmdline_parser_print_help (void)$/;"	f
cmdline_parser_print_version	cmdline.cc	/^cmdline_parser_print_version (void)$/;"	f
cmdline_parser_release	cmdline.cc	/^cmdline_parser_release (struct gengetopt_args_info *args_info)$/;"	f	file:
cmdline_parser_required	cmdline.cc	/^cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)$/;"	f
cmdline_parser_required2	cmdline.cc	/^cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)$/;"	f
comp_time	Generator.h	/^    Generator* comp_time;$/;"	m	class:CustomKeyGenerator
cond	barrier.h	/^    pthread_cond_t cond;$/;"	m	struct:__anon6
connect_agent	common.cc	/^void connect_agent(void) {$/;"	f
connect_to_server	TCPConnection.cc	/^bool TCPConnection::connect_to_server() {$/;"	f	class:TCPConnection
connected	DPDKConnection.h	/^	bool connected;$/;"	m	class:DPDKConnection
connections	ConnectionOptions.h	/^  int connections;$/;"	m	struct:__anon9
connections_arg	cmdline.h	/^  int connections_arg;	\/**< @brief Connections to establish per server. (default='1').  *\/$/;"	m	struct:gengetopt_args_info
connections_given	cmdline.h	/^  unsigned int connections_given ;	\/**< @brief Whether connections was given.  *\/$/;"	m	struct:gengetopt_args_info
connections_help	cmdline.h	/^  const char *connections_help; \/**< @brief Connections to establish per server. help description.  *\/$/;"	m	struct:gengetopt_args_info
connections_orig	cmdline.h	/^  char * connections_orig;	\/**< @brief Connections to establish per server. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
consume_binary_response	TCPConnection.cc	/^bool TCPConnection::consume_binary_response(evbuffer *input) {$/;"	f	class:TCPConnection
consume_header	DPDKConnection.cc	/^void DPDKConnection::consume_header(const char *data, size_t length)$/;"	f	class:DPDKConnection
consume_rest	DPDKConnection.cc	/^void DPDKConnection::consume_rest(const char *data, size_t length)$/;"	f	class:DPDKConnection
consume_tcp_binary_response	DPDKConnection.cc	/^bool DPDKConnection::consume_tcp_binary_response(const char *data, size_t length)$/;"	f	class:DPDKConnection
consume_udp_binary_response	UDPConnection.cc	/^Operation *UDPConnection::consume_udp_binary_response(char *data, size_t length)$/;"	f	class:UDPConnection
cpu_core_arg	cmdline.h	/^  int cpu_core_arg;	\/**< @brief The CPU core to run the agent on..  *\/$/;"	m	struct:gengetopt_args_info
cpu_core_given	cmdline.h	/^  unsigned int cpu_core_given ;	\/**< @brief Whether cpu-core was given.  *\/$/;"	m	struct:gengetopt_args_info
cpu_core_help	cmdline.h	/^  const char *cpu_core_help; \/**< @brief The CPU core to run the agent on. help description.  *\/$/;"	m	struct:gengetopt_args_info
cpu_core_orig	cmdline.h	/^  char * cpu_core_orig;	\/**< @brief The CPU core to run the agent on. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
createFacebookIA	Generator.cc	/^Generator* createFacebookIA() { return new GPareto(0, 16.0292, 0.154971); }$/;"	f
createFacebookKey	Generator.cc	/^Generator* createFacebookKey() { return new GEV(30.7984, 8.20449, 0.078688); }$/;"	f
createFacebookValue	Generator.cc	/^Generator* createFacebookValue() {$/;"	f
createGenerator	Generator.cc	/^Generator* createGenerator(std::string str) {$/;"	f
createPopGenLock	Generator.cc	/^static std::mutex createPopGenLock;$/;"	v	file:
createPopularityGenerator	Generator.cc	/^Generator *createPopularityGenerator(std::string str, long records, long permutation_seed) {$/;"	f
customkeygen	TCPConnection.h	/^  CustomKeyGenerator *customkeygen;$/;"	m	class:TCPConnection
data_length	TCPConnection.h	/^  int data_length;  \/\/ When waiting for data, how much we're peeking for.$/;"	m	class:TCPConnection
data_off	dpdktcp.c	/^	uint8_t data_off;$/;"	m	struct:tcp_hdr	file:
data_type	binary_protocol.h	/^  uint8_t data_type;$/;"	m	struct:__anon1
datagrams	binary_protocol.h	/^  uint16_t datagrams;$/;"	m	struct:__anon3
def	Generator.h	/^  Generator *def;$/;"	m	class:Discrete
default_string_arg	cmdline.cc	/^    const char *default_string_arg;$/;"	m	union:generic_value	file:
deleteGenerator	Generator.cc	/^void deleteGenerator(Generator* gen) {$/;"	f
depth	ConnectionOptions.h	/^  int depth;$/;"	m	struct:__anon9
depth_arg	cmdline.h	/^  int depth_arg;	\/**< @brief Maximum depth to pipeline requests. Agents may locally override this setting. (default='1').  *\/$/;"	m	struct:gengetopt_args_info
depth_given	cmdline.h	/^  unsigned int depth_given ;	\/**< @brief Whether depth was given.  *\/$/;"	m	struct:gengetopt_args_info
depth_help	cmdline.h	/^  const char *depth_help; \/**< @brief Maximum depth to pipeline requests. Agents may locally override this setting. help description.  *\/$/;"	m	struct:gengetopt_args_info
depth_orig	cmdline.h	/^  char * depth_orig;	\/**< @brief Maximum depth to pipeline requests. Agents may locally override this setting. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
disconnect_from_server	TCPConnection.cc	/^bool TCPConnection::disconnect_from_server() {$/;"	f	class:TCPConnection
distribution_t	distributions.h	/^enum distribution_t { UNIFORM, EXPONENTIAL, ZIPFIAN, LATEST };$/;"	g
distributions	distributions.cc	/^const char* distributions[] =$/;"	v
do_mutilate	mutilate.cc	/^void do_mutilate(const vector<string>& servers, options_t& options,$/;"	f
double_to_tv	util.h	/^inline void double_to_tv(double val, struct timeval *tv) {$/;"	f
dpdk_init	dpdktcp.c	/^void dpdk_init(int core, const struct rte_ether_addr *mac, uint32_t ip)$/;"	f
dpdk_loop	dpdktcp.c	/^void dpdk_loop(void)$/;"	f
drive_write_machine	DPDKConnection.cc	/^void DPDKConnection::drive_write_machine(double now)$/;"	f	class:DPDKConnection
drive_write_machine	TCPConnection.cc	/^void TCPConnection::drive_write_machine(double now) {$/;"	f	class:TCPConnection
drive_write_machine	UDPConnection.cc	/^void UDPConnection::drive_write_machine(double now)$/;"	f	class:UDPConnection
dst_addr	dpdktcp.c	/^	uint32_t dst_addr;$/;"	m	struct:ipv4_hdr	file:
dst_port	dpdktcp.c	/^	uint16_t dst_port;$/;"	m	struct:tcp_hdr	file:
e	Generator.h	/^  Exponential e;$/;"	m	class:GEV
earliest_last_xmit	UDPConnection.cc	/^Operation *OpQueue::earliest_last_xmit(void)$/;"	f	class:OpQueue
end	UDPConnection.cc	/^std::list<Operation>::iterator OpQueue::end()$/;"	f	class:OpQueue
end_time	Operation.h	/^  double start_time, end_time;$/;"	m	class:Operation
eta	Generator.h	/^  double eta;$/;"	m	class:Zipf
eth_input	dpdktcp.c	/^static void eth_input(struct rte_mbuf *mbuf)$/;"	f	file:
evdns	TCPConnection.h	/^  struct evdns_base *evdns;$/;"	m	class:TCPConnection	typeref:struct:TCPConnection::evdns_base
event_callback	TCPConnection.cc	/^void TCPConnection::event_callback(short events) {$/;"	f	class:TCPConnection
execute	ez_mutilate.py	/^  def execute(self, id, cmdline):$/;"	m	class:Runner
extra_len	binary_protocol.h	/^  uint8_t extra_len;$/;"	m	struct:__anon1
extras	binary_protocol.h	/^  uint64_t extras;$/;"	m	struct:__anon1
fd	UDPConnection.h	/^	int fd;$/;"	m	class:UDPConnection
find	UDPConnection.cc	/^Operation *OpQueue::find(uint16_t req_id)$/;"	f	class:OpQueue
finish_agent	common.cc	/^void finish_agent(ConnectionStats &stats) {$/;"	f
finish_barrier	mutilate.cc	/^pthread_barrier_t finish_barrier;$/;"	v
finish_barrier	mutilatedpdk.cc	/^pthread_barrier_t finish_barrier;$/;"	v
finish_barrier	mutilateudp.cc	/^pthread_barrier_t finish_barrier;$/;"	v
float_arg	cmdline.cc	/^    float float_arg;$/;"	m	union:generic_value	file:
fnv_64	util.h	/^inline uint64_t fnv_64(uint64_t in) { return fnv_64_buf(&in, sizeof(in)); }$/;"	f
fnv_64_buf	util.cc	/^uint64_t fnv_64_buf(const void* buf, size_t len) {$/;"	f
free_cmd_list	cmdline.cc	/^free_cmd_list(void)$/;"	f	file:
free_list	cmdline.cc	/^void free_list(struct generic_list *list, short string_arg)$/;"	f	file:
free_multiple_string_field	cmdline.cc	/^free_multiple_string_field(unsigned int len, char ***arg, char ***orig)$/;"	f	file:
free_string_field	cmdline.cc	/^free_string_field (char **s)$/;"	f	file:
g	Generator.h	/^  Generator* g;$/;"	m	class:KeyGenerator
generate	Generator.h	/^  std::string generate() {$/;"	f	class:CustomKeyGenerator
generate	Generator.h	/^  std::string generate(uint64_t ind) {$/;"	f	class:KeyGenerator
generate	Generator.h	/^  virtual double generate(double U = -1.0) { return value; }$/;"	f	class:Fixed
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:Bimodal
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:Discrete
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:Exponential
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:FileGenerator
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:GEV
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:GPareto
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:LogNormal
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:Normal
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:Uniform
generate	Generator.h	/^  virtual double generate(double U = -1.0) {$/;"	f	class:Zipf
generate_key	util.cc	/^void generate_key(int n, int length, char *buf) {$/;"	f
generate_normal	distributions.cc	/^double generate_normal(double mean, double sd) {$/;"	f
generate_poisson	distributions.cc	/^double generate_poisson(double lambda) {$/;"	f
generate_uniform	distributions.cc	/^double generate_uniform(double lambda) {$/;"	f
generic_list	cmdline.cc	/^struct generic_list$/;"	s	file:
generic_value	cmdline.cc	/^union generic_value {$/;"	u	file:
gengetopt_args_info	cmdline.h	/^struct gengetopt_args_info$/;"	s
gengetopt_args_info_description	cmdline.cc	/^const char *gengetopt_args_info_description = "\\"High-performance\\" memcached benchmarking tool";$/;"	v
gengetopt_args_info_help	cmdline.cc	/^const char *gengetopt_args_info_help[] = {$/;"	v
gengetopt_args_info_purpose	cmdline.cc	/^const char *gengetopt_args_info_purpose = "";$/;"	v
gengetopt_args_info_usage	cmdline.cc	/^const char *gengetopt_args_info_usage = "Usage: mutilate -s server[:port] [options]";$/;"	v
gengetopt_args_info_versiontext	cmdline.cc	/^const char *gengetopt_args_info_versiontext = "";$/;"	v
gengetopt_strdup	cmdline.cc	/^gengetopt_strdup (const char *s)$/;"	f
get_distribution	distributions.cc	/^distribution_t get_distribution(const char *name) {$/;"	f
get_misses	AgentStats.h	/^  uint64_t gets, sets, get_misses;$/;"	m	class:AgentStats
get_misses	ConnectionStats.h	/^  uint64_t gets, sets, get_misses;$/;"	m	class:ConnectionStats
get_multiple_arg_token	cmdline.cc	/^get_multiple_arg_token(const char *arg)$/;"	f	file:
get_multiple_arg_token_next	cmdline.cc	/^get_multiple_arg_token_next(const char *arg)$/;"	f	file:
get_nth	ConnectionStats.h	/^  double get_nth(double nth) {$/;"	f	class:ConnectionStats
get_nth	HistogramSampler.h	/^  double get_nth(double nth) {$/;"	f	class:HistogramSampler
get_nth	LogHistogramSampler.h	/^  double get_nth(double nth) {$/;"	f	class:LogHistogramSampler
get_qps	ConnectionStats.h	/^  double get_qps() {$/;"	f	class:ConnectionStats
get_sampler	ConnectionStats.h	/^  AdaptiveSampler<Operation> get_sampler;$/;"	m	class:ConnectionStats
get_sampler	ConnectionStats.h	/^  HistogramSampler get_sampler;$/;"	m	class:ConnectionStats
get_sampler	ConnectionStats.h	/^  LogHistogramSampler get_sampler;$/;"	m	class:ConnectionStats
get_time	util.h	/^inline double get_time() {$/;"	f
get_time_accurate	util.h	/^inline double get_time_accurate() {$/;"	f
getcount	ConnectionOptions.h	/^  char getcount[32];$/;"	m	struct:__anon9
getcount	TCPConnection.h	/^  Generator *getcount;$/;"	m	class:TCPConnection
getcount_arg	cmdline.h	/^  char * getcount_arg;	\/**< @brief Number of gets in multiget (distribution). (default='1').  *\/$/;"	m	struct:gengetopt_args_info
getcount_given	cmdline.h	/^  unsigned int getcount_given ;	\/**< @brief Whether getcount was given.  *\/$/;"	m	struct:gengetopt_args_info
getcount_help	cmdline.h	/^  const char *getcount_help; \/**< @brief Number of gets in multiget (distribution). help description.  *\/$/;"	m	struct:gengetopt_args_info
getcount_orig	cmdline.h	/^  char * getcount_orig;	\/**< @brief Number of gets in multiget (distribution). original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
getopt	ez_mutilate.py	/^def getopt(args, short, long, has_value = True):$/;"	f
gets	AgentStats.h	/^  uint64_t gets, sets, get_misses;$/;"	m	class:AgentStats
gets	ConnectionStats.h	/^  uint64_t gets, sets, get_misses;$/;"	m	class:ConnectionStats
go	mutilate.cc	/^void go(const vector<string>& servers, options_t& options,$/;"	f
header_len	dpdktcp.c	/^	uint8_t header_len: 4, version: 4;$/;"	m	struct:ipv4_hdr	file:
help_given	cmdline.h	/^  unsigned int help_given ;	\/**< @brief Whether help was given.  *\/$/;"	m	struct:gengetopt_args_info
help_help	cmdline.h	/^  const char *help_help; \/**< @brief Print help and exit help description.  *\/$/;"	m	struct:gengetopt_args_info
hostname	TCPConnection.h	/^  string hostname;$/;"	m	class:TCPConnection
ia	ConnectionOptions.h	/^  char ia[32];$/;"	m	struct:__anon9
iadist	ConnectionOptions.h	/^  enum distribution_t iadist;$/;"	m	struct:__anon9	typeref:enum:__anon9::distribution_t
iadist_arg	cmdline.h	/^  char * iadist_arg;	\/**< @brief Inter-arrival distribution (distribution).  Note: The distribution will automatically be adjusted to match the QPS given by --qps. (default='exponential').  *\/$/;"	m	struct:gengetopt_args_info
iadist_given	cmdline.h	/^  unsigned int iadist_given ;	\/**< @brief Whether iadist was given.  *\/$/;"	m	struct:gengetopt_args_info
iadist_help	cmdline.h	/^  const char *iadist_help; \/**< @brief Inter-arrival distribution (distribution).  Note: The distribution will automatically be adjusted to match the QPS given by --qps. help description.  *\/$/;"	m	struct:gengetopt_args_info
iadist_orig	cmdline.h	/^  char * iadist_orig;	\/**< @brief Inter-arrival distribution (distribution).  Note: The distribution will automatically be adjusted to match the QPS given by --qps. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
iagen	DPDKConnection.h	/^	Generator *iagen;$/;"	m	class:DPDKConnection
iagen	TCPConnection.h	/^  Generator *iagen;$/;"	m	class:TCPConnection
iagen	UDPConnection.h	/^	Generator *iagen;$/;"	m	class:UDPConnection
id	dpdktcp.c	/^	uint16_t id;$/;"	m	struct:ipv4_hdr	file:
init_agent	common.cc	/^void init_agent(zmq::socket_t &socket, options_t &options, vector<string> &servers) {$/;"	f
init_args_info	cmdline.cc	/^void init_args_info(struct gengetopt_args_info *args_info)$/;"	f	file:
init_random_stuff	common.cc	/^void init_random_stuff() {$/;"	f
initialize	cmdline.h	/^  int initialize; \/**< @brief whether to initialize the option structure gengetopt_args_info (default 1) *\/$/;"	m	struct:cmdline_parser_params
int_arg	cmdline.cc	/^    int int_arg;$/;"	m	union:generic_value	file:
ipv4_cksum	dpdktcp.c	/^static uint16_t ipv4_cksum(struct ipv4_hdr *ipv4_hdr)$/;"	f	file:
ipv4_hdr	dpdktcp.c	/^struct ipv4_hdr {$/;"	s	file:
is_connected_to_server	TCPConnection.cc	/^bool TCPConnection::is_connected_to_server() {$/;"	f	class:TCPConnection
issue_get	DPDKConnection.cc	/^void DPDKConnection::issue_get(string *key, double now)$/;"	f	class:DPDKConnection
issue_get	TCPConnection.cc	/^void TCPConnection::issue_get(const char* key, double now) {$/;"	f	class:TCPConnection
issue_get	UDPConnection.cc	/^void UDPConnection::issue_get(Operation &op)$/;"	f	class:UDPConnection
issue_get	UDPConnection.cc	/^void UDPConnection::issue_get(string *key, double now)$/;"	f	class:UDPConnection
issue_gets	AgentStats.h	/^  uint64_t issue_gets;$/;"	m	class:AgentStats
issue_gets	ConnectionStats.h	/^  uint64_t issue_gets;$/;"	m	class:ConnectionStats
issue_sasl	TCPConnection.cc	/^void TCPConnection::issue_sasl() {$/;"	f	class:TCPConnection
issue_set	DPDKConnection.cc	/^void DPDKConnection::issue_set(string* key, const char* value, int length, double now)$/;"	f	class:DPDKConnection
issue_set	TCPConnection.cc	/^void TCPConnection::issue_set(const char* key, const char* value, int length,$/;"	f	class:TCPConnection
issue_something	DPDKConnection.cc	/^void DPDKConnection::issue_something(double now)$/;"	f	class:DPDKConnection
issue_something	TCPConnection.cc	/^void TCPConnection::issue_something(double now) {$/;"	f	class:TCPConnection
issue_something	UDPConnection.cc	/^void UDPConnection::issue_something(Operation &op)$/;"	f	class:UDPConnection
issue_something	UDPConnection.cc	/^void UDPConnection::issue_something(double now)$/;"	f	class:UDPConnection
key	Operation.h	/^  string key;$/;"	m	class:Operation
key_len	binary_protocol.h	/^  uint16_t key_len;$/;"	m	struct:__anon1
keygen	DPDKConnection.h	/^	KeyGenerator *keygen;$/;"	m	class:DPDKConnection
keygen	TCPConnection.h	/^  KeyGenerator *keygen;$/;"	m	class:TCPConnection
keygen	UDPConnection.h	/^	KeyGenerator *keygen;$/;"	m	class:UDPConnection
keysize	ConnectionOptions.h	/^  char keysize[32];$/;"	m	struct:__anon9
keysize	TCPConnection.h	/^  Generator *keysize;$/;"	m	class:TCPConnection
keysize_arg	cmdline.h	/^  char * keysize_arg;	\/**< @brief Length of memcached keys (distribution). (default='30').  *\/$/;"	m	struct:gengetopt_args_info
keysize_given	cmdline.h	/^  unsigned int keysize_given ;	\/**< @brief Whether keysize was given.  *\/$/;"	m	struct:gengetopt_args_info
keysize_help	cmdline.h	/^  const char *keysize_help; \/**< @brief Length of memcached keys (distribution). help description.  *\/$/;"	m	struct:gengetopt_args_info
keysize_orig	cmdline.h	/^  char * keysize_orig;	\/**< @brief Length of memcached keys (distribution). original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
lambda	ConnectionOptions.h	/^  double lambda;$/;"	m	struct:__anon9
lambda	Generator.h	/^  double lambda;$/;"	m	class:Exponential
lambda_denom	ConnectionOptions.h	/^  int lambda_denom;$/;"	m	struct:__anon9
lambda_mul_arg	cmdline.h	/^  int lambda_mul_arg;	\/**< @brief Lambda multiplier.  Increases share of QPS for this client. (default='1').  *\/$/;"	m	struct:gengetopt_args_info
lambda_mul_given	cmdline.h	/^  unsigned int lambda_mul_given ;	\/**< @brief Whether lambda_mul was given.  *\/$/;"	m	struct:gengetopt_args_info
lambda_mul_help	cmdline.h	/^  const char *lambda_mul_help; \/**< @brief Lambda multiplier.  Increases share of QPS for this client. help description.  *\/$/;"	m	struct:gengetopt_args_info
lambda_mul_orig	cmdline.h	/^  char * lambda_mul_orig;	\/**< @brief Lambda multiplier.  Increases share of QPS for this client. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
last_rx	TCPConnection.h	/^  double last_rx; \/\/ Used to moderate transmission rate.$/;"	m	class:TCPConnection
last_tx	TCPConnection.h	/^  double last_tx;$/;"	m	class:TCPConnection
last_xmit	Operation.h	/^  double last_xmit;$/;"	m	class:Operation
len	dpdktcp.c	/^	uint16_t len;$/;"	m	struct:ipv4_hdr	file:
line_list	cmdline.cc	/^struct line_list$/;"	s	file:
list	UDPConnection.h	/^	std::list<Operation> list;$/;"	m	class:OpQueue
loader_completed	TCPConnection.h	/^  int loader_issued, loader_completed;$/;"	m	class:TCPConnection
loader_issued	TCPConnection.h	/^  int loader_issued, loader_completed;$/;"	m	class:TCPConnection
loadonly	ConnectionOptions.h	/^  bool loadonly;$/;"	m	struct:__anon9
loadonly_given	cmdline.h	/^  unsigned int loadonly_given ;	\/**< @brief Whether loadonly was given.  *\/$/;"	m	struct:gengetopt_args_info
loadonly_help	cmdline.h	/^  const char *loadonly_help; \/**< @brief Load database and then exit. help description.  *\/$/;"	m	struct:gengetopt_args_info
loc	Generator.h	/^  double loc \/* mu *\/, scale \/* sigma *\/, shape \/* k *\/;$/;"	m	class:GEV
loc	Generator.h	/^  double loc \/* mu *\/;$/;"	m	class:GPareto
local_ip	dpdktcp.c	/^static uint32_t local_ip;$/;"	v	file:
local_mac	dpdktcp.c	/^static struct rte_ether_addr local_mac;$/;"	v	typeref:struct:rte_ether_addr	file:
local_port	TCPConnection.h	/^  int local_port;$/;"	m	class:TCPConnection
local_port	dpdktcp.c	/^	uint16_t local_port;$/;"	m	struct:pcb	file:
local_tcp_port_start	dpdktcp.c	/^static int local_tcp_port_start;$/;"	v	file:
log_file_line	Generator.cc	/^void log_file_line(log_level_t, char const*, int, char const*, ...)$/;"	f
log_file_line	log.cc	/^void log_file_line(log_level_t level, const char *file, int line,$/;"	f
log_get	ConnectionStats.h	/^  void log_get(Operation& op) { if (sampling) get_sampler.sample(op); gets++; }$/;"	f	class:ConnectionStats
log_level	log.cc	/^log_level_t log_level = INFO;$/;"	v
log_level_t	log.h	/^enum log_level_t { DEBUG, VERBOSE, INFO, WARN, QUIET };$/;"	g
log_op	ConnectionStats.h	/^  void log_op (double op)     { if (sampling)  op_sampler.sample(op); }$/;"	f	class:ConnectionStats
log_set	ConnectionStats.h	/^  void log_set(Operation& op) { if (sampling) set_sampler.sample(op); sets++; }$/;"	f	class:ConnectionStats
magic	binary_protocol.h	/^  uint8_t magic;$/;"	m	struct:__anon1
main	.sconf_temp/conftest_22672a40009b753ad031061da2671748_0.cpp	/^main() {$/;"	f
main	.sconf_temp/conftest_5ecee485380decac59c41e4c321aa16c_0.cpp	/^main() {$/;"	f
main	.sconf_temp/conftest_737c003a897167642b70f8cdde8a0eaf_0.cpp	/^int main(void)$/;"	f
main	.sconf_temp/conftest_7b3d48683785d30d261220d44b9e5543_0.cpp	/^main() {$/;"	f
main	.sconf_temp/conftest_95d8ce25e7aee662b7f16d580c4241a4_0.cpp	/^main() {$/;"	f
main	.sconf_temp/conftest_a335ff4fd3029f354e728bf32beea92b_0.cpp	/^int main(void)$/;"	f
main	.sconf_temp/conftest_a66298d58fe2b8e56b6106a5c336b7d6_0.c	/^int main(void) {$/;"	f
main	Generator.cc	/^int main(int argc, char **argv)$/;"	f
main	TestGenerator.cc	/^int main(int argc, char **argv) {$/;"	f
main	ez_mutilate.py	/^def main():$/;"	f
main	mutilate.cc	/^int main(int argc, char **argv) {$/;"	f
main	mutilate_merge_logs.py	/^def main():$/;"	f
main	mutilatedpdk.cc	/^int main(int argc, char **argv)$/;"	f
main	mutilateudp.cc	/^int main(int argc, char **argv)$/;"	f
master	mutilate.cc	/^  bool master;  \/\/ Thread #0, not to be confused with agent master.$/;"	m	struct:thread_data	file:
master	mutilatedpdk.cc	/^static void master(void)$/;"	f	file:
master	mutilateudp.cc	/^static void master(void)$/;"	f	file:
master_boot_time	ConnectionOptions.h	/^  double master_boot_time;$/;"	m	struct:__anon9
max	ConnectionOptions.h	/^  int max;$/;"	m	struct:qps_function_sin_noise
max	ConnectionOptions.h	/^  int max;$/;"	m	struct:qps_function_triangle
max	Generator.h	/^  double max;$/;"	m	class:KeyGenerator
max_hold	ConnectionOptions.h	/^  double max_hold;$/;"	m	struct:qps_function_triangle
max_samples	AdaptiveSampler.h	/^  unsigned int max_samples;$/;"	m	class:AdaptiveSampler
mbuf_pool	dpdktcp.c	/^static struct rte_mempool *mbuf_pool;$/;"	v	typeref:struct:rte_mempool	file:
mean	Generator.h	/^  double mean, sd;$/;"	m	class:Normal
measure_connections_arg	cmdline.h	/^  int measure_connections_arg;	\/**< @brief Master client connections per server, overrides --connections..  *\/$/;"	m	struct:gengetopt_args_info
measure_connections_given	cmdline.h	/^  unsigned int measure_connections_given ;	\/**< @brief Whether measure_connections was given.  *\/$/;"	m	struct:gengetopt_args_info
measure_connections_help	cmdline.h	/^  const char *measure_connections_help; \/**< @brief Master client connections per server, overrides --connections. help description.  *\/$/;"	m	struct:gengetopt_args_info
measure_connections_orig	cmdline.h	/^  char * measure_connections_orig;	\/**< @brief Master client connections per server, overrides --connections. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
measure_depth_arg	cmdline.h	/^  int measure_depth_arg;	\/**< @brief Set master client connection depth..  *\/$/;"	m	struct:gengetopt_args_info
measure_depth_given	cmdline.h	/^  unsigned int measure_depth_given ;	\/**< @brief Whether measure_depth was given.  *\/$/;"	m	struct:gengetopt_args_info
measure_depth_help	cmdline.h	/^  const char *measure_depth_help; \/**< @brief Set master client connection depth. help description.  *\/$/;"	m	struct:gengetopt_args_info
measure_depth_orig	cmdline.h	/^  char * measure_depth_orig;	\/**< @brief Set master client connection depth. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
measure_qps	ConnectionOptions.h	/^  int measure_qps;$/;"	m	struct:__anon9
measure_qps_arg	cmdline.h	/^  int measure_qps_arg;	\/**< @brief Explicitly set master client QPS, spread across threads and connections..  *\/$/;"	m	struct:gengetopt_args_info
measure_qps_given	cmdline.h	/^  unsigned int measure_qps_given ;	\/**< @brief Whether measure_qps was given.  *\/$/;"	m	struct:gengetopt_args_info
measure_qps_help	cmdline.h	/^  const char *measure_qps_help; \/**< @brief Explicitly set master client QPS, spread across threads and connections. help description.  *\/$/;"	m	struct:gengetopt_args_info
measure_qps_orig	cmdline.h	/^  char * measure_qps_orig;	\/**< @brief Explicitly set master client QPS, spread across threads and connections. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
min	ConnectionOptions.h	/^  int min;$/;"	m	struct:qps_function_sin_noise
min	ConnectionOptions.h	/^  int min;$/;"	m	struct:qps_function_triangle
minimum	LogHistogramSampler.h	/^  double minimum() {$/;"	f	class:LogHistogramSampler
moderate	ConnectionOptions.h	/^  bool moderate;$/;"	m	struct:__anon9
moderate_given	cmdline.h	/^  unsigned int moderate_given ;	\/**< @brief Whether moderate was given.  *\/$/;"	m	struct:gengetopt_args_info
moderate_help	cmdline.h	/^  const char *moderate_help; \/**< @brief Enforce a minimum delay of ~1\/lambda between requests. help description.  *\/$/;"	m	struct:gengetopt_args_info
mu	Generator.h	/^  double mu, sigma;$/;"	m	class:LogNormal
mutex	barrier.h	/^    pthread_mutex_t mutex;$/;"	m	struct:__anon6
my_ip_arg	cmdline.h	/^  char * my_ip_arg;	\/**< @brief The IP address of the agent..  *\/$/;"	m	struct:gengetopt_args_info
my_ip_given	cmdline.h	/^  unsigned int my_ip_given ;	\/**< @brief Whether my-ip was given.  *\/$/;"	m	struct:gengetopt_args_info
my_ip_help	cmdline.h	/^  const char *my_ip_help; \/**< @brief The IP address of the agent. help description.  *\/$/;"	m	struct:gengetopt_args_info
my_ip_orig	cmdline.h	/^  char * my_ip_orig;	\/**< @brief The IP address of the agent. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
my_mac_arg	cmdline.h	/^  char * my_mac_arg;	\/**< @brief The MAC address of the agent..  *\/$/;"	m	struct:gengetopt_args_info
my_mac_given	cmdline.h	/^  unsigned int my_mac_given ;	\/**< @brief Whether my-mac was given.  *\/$/;"	m	struct:gengetopt_args_info
my_mac_help	cmdline.h	/^  const char *my_mac_help; \/**< @brief The MAC address of the agent. help description.  *\/$/;"	m	struct:gengetopt_args_info
my_mac_orig	cmdline.h	/^  char * my_mac_orig;	\/**< @brief The MAC address of the agent. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
n	Generator.h	/^  int n;$/;"	m	class:Zipf
n	common.h	/^  int n;$/;"	m	struct:scan_search_params_struct
name_to_ipaddr	mutilate.cc	/^string name_to_ipaddr(string host) {$/;"	f
needed	barrier.h	/^    int needed;$/;"	m	struct:__anon6
next	cmdline.cc	/^  struct generic_list *next;$/;"	m	struct:generic_list	typeref:struct:generic_list::generic_list	file:
next	cmdline.cc	/^  struct line_list * next;$/;"	m	struct:line_list	typeref:struct:line_list::line_list	file:
next_time	DPDKConnection.h	/^	double next_time;$/;"	m	class:DPDKConnection
next_time	TCPConnection.h	/^  double next_time; \/\/ Inter-transmission time parameters.$/;"	m	class:TCPConnection
next_time	UDPConnection.h	/^	double next_time;$/;"	m	class:UDPConnection
no_nodelay	ConnectionOptions.h	/^  bool no_nodelay;$/;"	m	struct:__anon9
no_nodelay_given	cmdline.h	/^  unsigned int no_nodelay_given ;	\/**< @brief Whether no_nodelay was given.  *\/$/;"	m	struct:gengetopt_args_info
no_nodelay_help	cmdline.h	/^  const char *no_nodelay_help; \/**< @brief Don't use TCP_NODELAY. help description.  *\/$/;"	m	struct:gengetopt_args_info
noise_amplitude	ConnectionOptions.h	/^  int noise_amplitude;$/;"	m	struct:qps_function_sin_noise
noise_update_interval	ConnectionOptions.h	/^  double noise_update_interval;$/;"	m	struct:qps_function_sin_noise
noload	ConnectionOptions.h	/^  bool noload;$/;"	m	struct:__anon9
noload_given	cmdline.h	/^  unsigned int noload_given ;	\/**< @brief Whether noload was given.  *\/$/;"	m	struct:gengetopt_args_info
noload_help	cmdline.h	/^  const char *noload_help; \/**< @brief Skip database loading. help description.  *\/$/;"	m	struct:gengetopt_args_info
normal	Generator.h	/^  Normal normal;$/;"	m	class:LogNormal
notice	mutilate_merge_logs.py	/^def notice():$/;"	f
numreq_count	TCPConnection.h	/^  unsigned long numreq_count;$/;"	m	class:TCPConnection
numreq_threshold	TCPConnection.h	/^  unsigned long numreq_threshold;$/;"	m	class:TCPConnection
numreq_threshold_gen	TCPConnection.h	/^  Generator* numreq_threshold_gen;$/;"	m	class:TCPConnection
numreqperconn	ConnectionOptions.h	/^  char numreqperconn[32];$/;"	m	struct:__anon9
numreqperconn_arg	cmdline.h	/^  char * numreqperconn_arg;	\/**< @brief Number of requests per connection (distribution). Once a connection reaches this number, it is torn down and re-started. This option facilitates experiments involving ongoing opening and closing of connections to the memcached server; it is passed to all agents and ignored on the master which takes samples. Default behaviour is to use the same connection for all requests. (default='0').  *\/$/;"	m	struct:gengetopt_args_info
numreqperconn_given	cmdline.h	/^  unsigned int numreqperconn_given ;	\/**< @brief Whether numreqperconn was given.  *\/$/;"	m	struct:gengetopt_args_info
numreqperconn_help	cmdline.h	/^  const char *numreqperconn_help; \/**< @brief Number of requests per connection (distribution). Once a connection reaches this number, it is torn down and re-started. This option facilitates experiments involving ongoing opening and closing of connections to the memcached server; it is passed to all agents and ignored on the master which takes samples. Default behaviour is to use the same connection for all requests. help description.  *\/$/;"	m	struct:gengetopt_args_info
numreqperconn_orig	cmdline.h	/^  char * numreqperconn_orig;	\/**< @brief Number of requests per connection (distribution). Once a connection reaches this number, it is torn down and re-started. This option facilitates experiments involving ongoing opening and closing of connections to the memcached server; it is passed to all agents and ignored on the master which takes samples. Default behaviour is to use the same connection for all requests. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
off	dpdktcp.c	/^	uint16_t off;$/;"	m	struct:ipv4_hdr	file:
on_tcp_connected	DPDKConnection.cc	/^void on_tcp_connected(void *arg)$/;"	f
on_tcp_recv	DPDKConnection.cc	/^void on_tcp_recv(void *arg, char *data, size_t len)$/;"	f
oob_thread	ConnectionOptions.h	/^  bool oob_thread;$/;"	m	struct:__anon9
op_queue	DPDKConnection.h	/^	std::queue<Operation> op_queue;$/;"	m	class:DPDKConnection
op_queue	TCPConnection.h	/^  std::queue<Operation> op_queue;$/;"	m	class:TCPConnection
op_queue	UDPConnection.h	/^	OpQueue op_queue;$/;"	m	class:UDPConnection
op_sampler	ConnectionStats.h	/^  AdaptiveSampler<double> op_sampler;$/;"	m	class:ConnectionStats
op_sampler	ConnectionStats.h	/^  HistogramSampler op_sampler;$/;"	m	class:ConnectionStats
op_sampler	ConnectionStats.h	/^  LogHistogramSampler op_sampler;$/;"	m	class:ConnectionStats
opaque	binary_protocol.h	/^  uint32_t opaque;$/;"	m	struct:__anon1
opcode	binary_protocol.h	/^  uint8_t opcode;$/;"	m	struct:__anon1
open_connections	mutilatedpdk.cc	/^static void open_connections(vector<DPDKConnection *> *connections)$/;"	f	file:
open_connections	mutilateudp.cc	/^static void open_connections(struct event_base *base, vector<UDPConnection *> *connections)$/;"	f	file:
options	DPDKConnection.h	/^	options_t options;$/;"	m	class:DPDKConnection
options	TCPConnection.h	/^  options_t options;$/;"	m	class:TCPConnection
options	UDPConnection.h	/^	options_t options;$/;"	m	class:UDPConnection
options	mutilate.cc	/^  options_t *options;$/;"	m	struct:thread_data	file:
options	mutilatedpdk.cc	/^static options_t options;$/;"	v	file:
options	mutilateudp.cc	/^static options_t options;$/;"	v	file:
options_t	ConnectionOptions.h	/^} options_t;$/;"	t	typeref:struct:__anon9
orig	cmdline.cc	/^  char *orig;$/;"	m	struct:generic_list	file:
overflow_sum	HistogramSampler.h	/^  double overflow_sum;$/;"	m	class:HistogramSampler
override	cmdline.h	/^  int override; \/**< @brief whether to override possibly already present options (default 0) *\/$/;"	m	struct:cmdline_parser_params
package_name	cmdline.cc	/^static char *package_name = 0;$/;"	v	file:
params	ConnectionOptions.h	/^  } params;$/;"	m	struct:qps_function_info	typeref:union:qps_function_info::__anon8
parse_generator_string	Generator.cc	/^char *parse_generator_string(std::string str, char **r1, char **r2, char **r3) {$/;"	f
parse_ip	DPDKConnection.cc	/^uint32_t parse_ip(const char *str)$/;"	f
parse_mac	DPDKConnection.cc	/^void parse_mac(const char *str, struct rte_ether_addr *res)$/;"	f
password	ConnectionOptions.h	/^  char password[32];$/;"	m	struct:__anon9
password_arg	cmdline.h	/^  char * password_arg;	\/**< @brief Password to use for SASL authentication..  *\/$/;"	m	struct:gengetopt_args_info
password_given	cmdline.h	/^  unsigned int password_given ;	\/**< @brief Whether password was given.  *\/$/;"	m	struct:gengetopt_args_info
password_help	cmdline.h	/^  const char *password_help; \/**< @brief Password to use for SASL authentication. help description.  *\/$/;"	m	struct:gengetopt_args_info
password_orig	cmdline.h	/^  char * password_orig;	\/**< @brief Password to use for SASL authentication. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
pcb	DPDKConnection.h	/^	struct pcb *pcb;$/;"	m	class:DPDKConnection	typeref:struct:DPDKConnection::pcb
pcb	dpdktcp.c	/^static struct pcb {$/;"	s	file:
pcb_idx	dpdktcp.c	/^static int pcb_idx;$/;"	v	file:
pcbs	dpdktcp.c	/^} pcbs[MAX_CONNECTIONS];$/;"	v	typeref:struct:pcb	file:
period	ConnectionOptions.h	/^  double period;$/;"	m	struct:qps_function_sin_noise
period	ConnectionOptions.h	/^  double period;$/;"	m	struct:qps_function_triangle
permutation	Generator.h	/^  int *permutation;$/;"	m	class:Zipf
permutation_seed	ConnectionOptions.h	/^  long permutation_seed;$/;"	m	struct:__anon9
pop	UDPConnection.cc	/^void OpQueue::pop(Operation *op)$/;"	f	class:OpQueue
pop_op	DPDKConnection.cc	/^void DPDKConnection::pop_op(Operation *op)$/;"	f	class:DPDKConnection
pop_op	TCPConnection.cc	/^void TCPConnection::pop_op() {$/;"	f	class:TCPConnection
pop_op	UDPConnection.cc	/^void UDPConnection::pop_op(Operation *op)$/;"	f	class:UDPConnection
popularity	ConnectionOptions.h	/^  char popularity[32];$/;"	m	struct:__anon9
popularity	TCPConnection.h	/^  Generator *popularity;$/;"	m	class:TCPConnection
popularity	UDPConnection.h	/^	Generator *popularity;$/;"	m	class:UDPConnection
popularityGenerator	Generator.cc	/^static Generator *popularityGenerator;$/;"	v	file:
popularity_arg	cmdline.h	/^  char * popularity_arg;	\/**< @brief Key popularity distribution. (default='uniform').  *\/$/;"	m	struct:gengetopt_args_info
popularity_given	cmdline.h	/^  unsigned int popularity_given ;	\/**< @brief Whether popularity was given.  *\/$/;"	m	struct:gengetopt_args_info
popularity_help	cmdline.h	/^  const char *popularity_help; \/**< @brief Key popularity distribution. help description.  *\/$/;"	m	struct:gengetopt_args_info
popularity_orig	cmdline.h	/^  char * popularity_orig;	\/**< @brief Key popularity distribution. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
populate_src_ports	mutilate.cc	/^void populate_src_ports(vector<int>& src_ports, int offset, int count) {$/;"	f
port	Operation.h	/^  int port;$/;"	m	class:Operation
port	TCPConnection.h	/^  string port;$/;"	m	class:TCPConnection
port_conf_default	dpdktcp.c	/^static const struct rte_eth_conf port_conf_default = {$/;"	v	typeref:struct:rte_eth_conf	file:
port_init	dpdktcp.c	/^static void port_init(uint8_t port, struct rte_mempool *mbuf_pool)$/;"	f	file:
prep_agent	common.cc	/^void prep_agent(const vector<string>& servers, options_t& options) {$/;"	f
print_errors	cmdline.h	/^  int print_errors; \/**< @brief whether getopt_long should print an error message for a bad option (default 1) *\/$/;"	m	struct:cmdline_parser_params
print_header	AdaptiveSampler.h	/^  void print_header() {$/;"	f	class:AdaptiveSampler
print_header	ConnectionStats.h	/^  static void print_header() {$/;"	f	class:ConnectionStats
print_help_common	cmdline.cc	/^static void print_help_common(void)$/;"	f	file:
print_stats	AdaptiveSampler.h	/^  void print_stats(const char *type, const char *size) {$/;"	f	class:AdaptiveSampler
print_stats	ConnectionStats.h	/^  void print_stats(const char *tag, AdaptiveSampler<Operation> &sampler,$/;"	f	class:ConnectionStats
print_stats	ConnectionStats.h	/^  void print_stats(const char *tag, AdaptiveSampler<double> &sampler,$/;"	f	class:ConnectionStats
print_stats	ConnectionStats.h	/^  void print_stats(const char *tag, HistogramSampler &sampler,$/;"	f	class:ConnectionStats
print_stats	ConnectionStats.h	/^  void print_stats(const char *tag, LogHistogramSampler &sampler,$/;"	f	class:ConnectionStats
print_stats	common.cc	/^void print_stats(ConnectionStats &stats, double boot_time, double peak_qps) {$/;"	f
problem	mutilatedpdk.cc	/^volatile int problem;$/;"	v
proto	dpdktcp.c	/^	uint8_t proto;$/;"	m	struct:ipv4_hdr	file:
prv_stats	common.cc	/^  ConnectionStats prv_stats;$/;"	m	struct:__anon4	file:
prv_time	common.cc	/^  double prv_time;$/;"	m	struct:__anon4	file:
pthread_barrier_attr_t	barrier.h	19;"	d
pthread_barrier_destroy	barrier.h	21;"	d
pthread_barrier_init	barrier.h	20;"	d
pthread_barrier_t	barrier.h	18;"	d
pthread_barrier_wait	barrier.h	22;"	d
push	UDPConnection.cc	/^void OpQueue::push(Operation op)$/;"	f	class:OpQueue
pv	Generator.h	/^  std::vector< std::pair<double,double> > pv;$/;"	m	class:Discrete
qps	ConnectionOptions.h	/^  int qps;$/;"	m	struct:__anon9
qps	common.h	/^  int qps;$/;"	m	struct:scan_search_ctx
qps_arg	cmdline.h	/^  int qps_arg;	\/**< @brief Target aggregate QPS. 0 = peak QPS. (default='0').  *\/$/;"	m	struct:gengetopt_args_info
qps_function	ConnectionOptions.h	/^  struct qps_function_info qps_function;$/;"	m	struct:__anon9	typeref:struct:__anon9::qps_function_info
qps_function_adjust	mutilate.cc	/^void qps_function_adjust(options_t *options, vector<TCPConnection*>& connections, int qps) {$/;"	f
qps_function_arg	cmdline.h	/^  char * qps_function_arg;	\/**< @brief Adjust the target QPS during the benchmark according to the given function..  *\/$/;"	m	struct:gengetopt_args_info
qps_function_calc	common.cc	/^int qps_function_calc(options_t *options, double t) {$/;"	f
qps_function_enabled	mutilate.cc	/^bool qps_function_enabled(options_t *options) {$/;"	f
qps_function_given	cmdline.h	/^  unsigned int qps_function_given ;	\/**< @brief Whether qps-function was given.  *\/$/;"	m	struct:gengetopt_args_info
qps_function_help	cmdline.h	/^  const char *qps_function_help; \/**< @brief Adjust the target QPS during the benchmark according to the given function. help description.  *\/$/;"	m	struct:gengetopt_args_info
qps_function_info	ConnectionOptions.h	/^struct qps_function_info {$/;"	s
qps_function_init	common.cc	/^void qps_function_init(options_t *options) {$/;"	f
qps_function_orig	cmdline.h	/^  char * qps_function_orig;	\/**< @brief Adjust the target QPS during the benchmark according to the given function. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
qps_function_qtriangle	ConnectionOptions.h	/^struct qps_function_qtriangle {$/;"	s
qps_function_sin_noise	ConnectionOptions.h	/^struct qps_function_sin_noise {$/;"	s
qps_function_triangle	ConnectionOptions.h	/^struct qps_function_triangle {$/;"	s
qps_function_type	ConnectionOptions.h	/^enum qps_function_type {$/;"	g
qps_given	cmdline.h	/^  unsigned int qps_given ;	\/**< @brief Whether qps was given.  *\/$/;"	m	struct:gengetopt_args_info
qps_help	cmdline.h	/^  const char *qps_help; \/**< @brief Target aggregate QPS. 0 = peak QPS. help description.  *\/$/;"	m	struct:gengetopt_args_info
qps_orig	cmdline.h	/^  char * qps_orig;	\/**< @brief Target aggregate QPS. 0 = peak QPS. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
qps_warmup_arg	cmdline.h	/^  char * qps_warmup_arg;	\/**< @brief Warmup at given rate or rate QPS_function(t=0) for the given number of seconds..  *\/$/;"	m	struct:gengetopt_args_info
qps_warmup_given	cmdline.h	/^  unsigned int qps_warmup_given ;	\/**< @brief Whether qps-warmup was given.  *\/$/;"	m	struct:gengetopt_args_info
qps_warmup_help	cmdline.h	/^  const char *qps_warmup_help; \/**< @brief Warmup at given rate or rate QPS_function(t=0) for the given number of seconds. help description.  *\/$/;"	m	struct:gengetopt_args_info
qps_warmup_orig	cmdline.h	/^  char * qps_warmup_orig;	\/**< @brief Warmup at given rate or rate QPS_function(t=0) for the given number of seconds. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
qtriangle	ConnectionOptions.h	/^    struct qps_function_qtriangle qtriangle;$/;"	m	union:qps_function_info::__anon8	typeref:struct:qps_function_info::__anon8::qps_function_qtriangle
qtriangle	common.cc	/^static int qtriangle(struct qps_function_qtriangle *p, double t) {$/;"	f	file:
quiet_given	cmdline.h	/^  unsigned int quiet_given ;	\/**< @brief Whether quiet was given.  *\/$/;"	m	struct:gengetopt_args_info
quiet_help	cmdline.h	/^  const char *quiet_help; \/**< @brief Disable log messages. help description.  *\/$/;"	m	struct:gengetopt_args_info
random_char	common.cc	/^char random_char[2 * 1024 * 1024];  \/\/ Buffer used to generate random values.$/;"	v
ratio	Generator.h	/^  double ratio, v1, v2;$/;"	m	class:Bimodal
read_callback	DPDKConnection.cc	/^void DPDKConnection::read_callback(const char *data, size_t len)$/;"	f	class:DPDKConnection
read_callback	TCPConnection.cc	/^void TCPConnection::read_callback() {$/;"	f	class:TCPConnection
read_callback	UDPConnection.cc	/^void UDPConnection::read_callback()$/;"	f	class:UDPConnection
read_cb	UDPConnection.cc	/^void read_cb(evutil_socket_t sock, short what, void *ptr)$/;"	f
read_state	DPDKConnection.h	/^	enum read_state_enum read_state;$/;"	m	class:DPDKConnection	typeref:enum:DPDKConnection::read_state_enum
read_state	TCPConnection.h	/^  read_state_enum read_state;$/;"	m	class:TCPConnection
read_state	UDPConnection.h	/^	enum read_state_enum read_state;$/;"	m	class:UDPConnection	typeref:enum:UDPConnection::read_state_enum
read_state_enum	Connection.h	/^  enum read_state_enum {$/;"	g	class:Connection
reader	ez_mutilate.py	/^  def reader(self):$/;"	m	class:Runner
received_stop	mutilate.cc	/^volatile bool received_stop;$/;"	v
received_stop	mutilatedpdk.cc	/^volatile bool received_stop;$/;"	v
received_stop	mutilateudp.cc	/^volatile bool received_stop;$/;"	v
records	ConnectionOptions.h	/^  int records;$/;"	m	struct:__anon9
records_arg	cmdline.h	/^  int records_arg;	\/**< @brief Number of memcached records to use.  If multiple memcached servers are given, this number is divided by the number of servers. (default='10000').  *\/$/;"	m	struct:gengetopt_args_info
records_given	cmdline.h	/^  unsigned int records_given ;	\/**< @brief Whether records was given.  *\/$/;"	m	struct:gengetopt_args_info
records_help	cmdline.h	/^  const char *records_help; \/**< @brief Number of memcached records to use.  If multiple memcached servers are given, this number is divided by the number of servers. help description.  *\/$/;"	m	struct:gengetopt_args_info
records_orig	cmdline.h	/^  char * records_orig;	\/**< @brief Number of memcached records to use.  If multiple memcached servers are given, this number is divided by the number of servers. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
recv_ack	dpdktcp.c	/^	uint32_t recv_ack;$/;"	m	struct:pcb	file:
recv_ack	dpdktcp.c	/^	uint32_t recv_ack;$/;"	m	struct:tcp_hdr	file:
region	common.h	/^  int region;$/;"	m	struct:scan_search_ctx
remaining	DPDKConnection.h	/^	uint32_t remaining;$/;"	m	class:DPDKConnection
remote_ip	dpdktcp.c	/^	uint32_t remote_ip;$/;"	m	struct:pcb	file:
remote_mac	dpdktcp.c	/^	struct rte_ether_addr remote_mac;$/;"	m	struct:pcb	typeref:struct:pcb::rte_ether_addr	file:
remote_port	dpdktcp.c	/^	uint16_t remote_port;$/;"	m	struct:pcb	file:
report_stats_arg	cmdline.h	/^  float report_stats_arg;	\/**< @brief Report statistics every interval seconds. By default, report at the end of the benchmark..  *\/$/;"	m	struct:gengetopt_args_info
report_stats_ctx	common.cc	/^} report_stats_ctx;$/;"	v	typeref:struct:__anon4	file:
report_stats_get	common.cc	/^ConnectionStats report_stats_get(double now, int qps) {$/;"	f
report_stats_given	cmdline.h	/^  unsigned int report_stats_given ;	\/**< @brief Whether report-stats was given.  *\/$/;"	m	struct:gengetopt_args_info
report_stats_help	cmdline.h	/^  const char *report_stats_help; \/**< @brief Report statistics every interval seconds. By default, report at the end of the benchmark. help description.  *\/$/;"	m	struct:gengetopt_args_info
report_stats_init	common.cc	/^void report_stats_init(void) {$/;"	f
report_stats_is_time	common.cc	/^bool report_stats_is_time(double now) {$/;"	f
report_stats_orig	cmdline.h	/^  char * report_stats_orig;	\/**< @brief Report statistics every interval seconds. By default, report at the end of the benchmark. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
report_stats_print	common.cc	/^void report_stats_print(double now, int qps, ConnectionStats &report_stats) {$/;"	f
req_id	Operation.h	/^  int req_id;$/;"	m	class:Operation
req_id	UDPConnection.h	/^	uint16_t req_id = 0;$/;"	m	class:UDPConnection
req_id	binary_protocol.h	/^  uint16_t req_id;$/;"	m	struct:__anon3
reserved	binary_protocol.h	/^  uint16_t reserved;$/;"	m	struct:__anon3
reset	TCPConnection.cc	/^void TCPConnection::reset() {$/;"	f	class:TCPConnection
reset_connection	TCPConnection.cc	/^bool TCPConnection::reset_connection() {$/;"	f	class:TCPConnection
reset_numreq_threshold	TCPConnection.cc	/^void TCPConnection::reset_numreq_threshold() {$/;"	f	class:TCPConnection
retransmit	UDPConnection.cc	/^void UDPConnection::retransmit(double now)$/;"	f	class:UDPConnection
retransmits	AgentStats.h	/^  uint64_t retransmits;$/;"	m	class:AgentStats
retransmits	ConnectionStats.h	/^  uint64_t retransmits;$/;"	m	class:ConnectionStats
rmopt	ez_mutilate.py	/^def rmopt(args, short, long, has_value = True):$/;"	f
roundrobin	ConnectionOptions.h	/^  bool roundrobin;$/;"	m	struct:__anon9
roundrobin_given	cmdline.h	/^  unsigned int roundrobin_given ;	\/**< @brief Whether roundrobin was given.  *\/$/;"	m	struct:gengetopt_args_info
roundrobin_help	cmdline.h	/^  const char *roundrobin_help; \/**< @brief Assign threads to servers in round-robin fashion.  By default, each thread connects to every server. help description.  *\/$/;"	m	struct:gengetopt_args_info
rx_bytes	AgentStats.h	/^  uint64_t rx_bytes, tx_bytes;$/;"	m	class:AgentStats
rx_bytes	ConnectionStats.h	/^  uint64_t rx_bytes, tx_bytes;$/;"	m	class:ConnectionStats
rx_win	dpdktcp.c	/^	uint16_t rx_win;$/;"	m	struct:tcp_hdr	file:
s_recv	common.cc	/^std::string s_recv (zmq::socket_t &socket) {$/;"	f
s_recv_msg	common.cc	/^zmq::message_t s_recv_msg(zmq::socket_t &socket) {$/;"	f
s_send	common.cc	/^bool s_send (zmq::socket_t &socket, const std::string &string) {$/;"	f
sample	AdaptiveSampler.h	/^  void sample(T s) {$/;"	f	class:AdaptiveSampler
sample	HistogramSampler.h	/^  void sample(const Operation &op) {$/;"	f	class:HistogramSampler
sample	HistogramSampler.h	/^  void sample(double s) {$/;"	f	class:HistogramSampler
sample	LogHistogramSampler.h	/^  void sample(const Operation &op) {$/;"	f	class:LogHistogramSampler
sample	LogHistogramSampler.h	/^  void sample(double s) {$/;"	f	class:LogHistogramSampler
sample_rate	AdaptiveSampler.h	/^  unsigned int sample_rate;$/;"	m	class:AdaptiveSampler
samples	AdaptiveSampler.h	/^  std::vector<T> samples;$/;"	m	class:AdaptiveSampler
samples	Generator.h	/^  std::vector<double> samples;$/;"	m	class:FileGenerator
samples	LogHistogramSampler.h	/^  std::vector<Operation> samples;$/;"	m	class:LogHistogramSampler
sampling	ConnectionStats.h	/^  bool sampling;$/;"	m	class:ConnectionStats
sasl	ConnectionOptions.h	/^  bool sasl;$/;"	m	struct:__anon9
save_arg	ConnectionOptions.h	/^  char save_arg[80];$/;"	m	struct:__anon9
save_arg	cmdline.h	/^  char * save_arg;	\/**< @brief Record latency samples to given file..  *\/$/;"	m	struct:gengetopt_args_info
save_given	cmdline.h	/^  unsigned int save_given ;	\/**< @brief Whether save was given.  *\/$/;"	m	struct:gengetopt_args_info
save_help	cmdline.h	/^  const char *save_help; \/**< @brief Record latency samples to given file. help description.  *\/$/;"	m	struct:gengetopt_args_info
save_orig	cmdline.h	/^  char * save_orig;	\/**< @brief Record latency samples to given file. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
save_samples	AdaptiveSampler.h	/^  void save_samples(const char* type, const char* filename) {$/;"	f	class:AdaptiveSampler
scale	Generator.h	/^  double loc \/* mu *\/, scale \/* sigma *\/, shape \/* k *\/;$/;"	m	class:GEV
scale	Generator.h	/^  double scale \/* sigma *\/, shape \/* k *\/;$/;"	m	class:GPareto
scale	Generator.h	/^  double scale;$/;"	m	class:Uniform
scan_arg	cmdline.h	/^  char * scan_arg;	\/**< @brief Scan latency across QPS rates from min to max..  *\/$/;"	m	struct:gengetopt_args_info
scan_given	cmdline.h	/^  unsigned int scan_given ;	\/**< @brief Whether scan was given.  *\/$/;"	m	struct:gengetopt_args_info
scan_help	cmdline.h	/^  const char *scan_help; \/**< @brief Scan latency across QPS rates from min to max. help description.  *\/$/;"	m	struct:gengetopt_args_info
scan_orig	cmdline.h	/^  char * scan_orig;	\/**< @brief Scan latency across QPS rates from min to max. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
scan_search_arg	cmdline.h	/^  char * scan_search_arg;	\/**< @brief Scan latency and search for the QPS. (i.e. --scan-search 95:1000,20:10:100,500:50 means scan from 20KQPS to 100KQPS in$/;"	m	struct:gengetopt_args_info
scan_search_calc	mutilate.cc	/^static int scan_search_calc() {$/;"	f	file:
scan_search_ctx	common.h	/^    struct scan_search_ctx scan_search_ctx;$/;"	m	union:agent_stats_msg::__anon10	typeref:struct:agent_stats_msg::__anon10::scan_search_ctx
scan_search_ctx	common.h	/^struct scan_search_ctx {$/;"	s
scan_search_enabled	ConnectionOptions.h	/^  bool scan_search_enabled;$/;"	m	struct:__anon9
scan_search_enabled	mutilate.cc	/^static bool scan_search_enabled(options_t *options) {$/;"	f	file:
scan_search_given	cmdline.h	/^  unsigned int scan_search_given ;	\/**< @brief Whether scan-search was given.  *\/$/;"	m	struct:gengetopt_args_info
scan_search_help	cmdline.h	/^  const char *scan_search_help; \/**< @brief Scan latency and search for the QPS. (i.e. --scan-search 95:1000,20:10:100,500:50 means scan from 20KQPS to 100KQPS in$/;"	m	struct:gengetopt_args_info
scan_search_init	common.cc	/^void scan_search_init(options_t *options) {$/;"	f
scan_search_orig	cmdline.h	/^  char * scan_search_orig;	\/**< @brief Scan latency and search for the QPS. (i.e. --scan-search 95:1000,20:10:100,500:50 means scan from 20KQPS to 100KQPS in$/;"	m	struct:gengetopt_args_info
scan_search_params	mutilate.cc	/^struct scan_search_params_struct scan_search_params;$/;"	v	typeref:struct:scan_search_params_struct
scan_search_params	mutilatedpdk.cc	/^struct scan_search_params_struct scan_search_params;$/;"	v	typeref:struct:scan_search_params_struct
scan_search_params	mutilateudp.cc	/^struct scan_search_params_struct scan_search_params;$/;"	v	typeref:struct:scan_search_params_struct
scan_search_params_struct	common.h	/^struct scan_search_params_struct {$/;"	s
scan_search_rx_ctx	common.cc	/^static void scan_search_rx_ctx(struct agent_stats_msg *msg) {$/;"	f	file:
scan_search_start	mutilate.cc	/^static void scan_search_start() {$/;"	f	file:
scan_search_tx_ctx	mutilate.cc	/^static void scan_search_tx_ctx() {$/;"	f	file:
scan_search_update	mutilate.cc	/^static bool scan_search_update(ConnectionStats *stats) {$/;"	f	file:
scan_search_wait	mutilate.cc	/^static void scan_search_wait() {$/;"	f	file:
scans_ctx	mutilate.cc	/^struct scan_search_ctx scans_ctx;$/;"	v	typeref:struct:scan_search_ctx
scans_ctx	mutilatedpdk.cc	/^struct scan_search_ctx scans_ctx;$/;"	v	typeref:struct:scan_search_ctx
scans_ctx	mutilateudp.cc	/^struct scan_search_ctx scans_ctx;$/;"	v	typeref:struct:scan_search_ctx
sd	Generator.h	/^  double mean, sd;$/;"	m	class:Normal
search_arg	cmdline.h	/^  char * search_arg;	\/**< @brief Search for the QPS where N-order statistic < Xus.  (i.e. --search 95:1000 means find the QPS where 95% of requests are faster than 1000us)..  *\/$/;"	m	struct:gengetopt_args_info
search_given	cmdline.h	/^  unsigned int search_given ;	\/**< @brief Whether search was given.  *\/$/;"	m	struct:gengetopt_args_info
search_help	cmdline.h	/^  const char *search_help; \/**< @brief Search for the QPS where N-order statistic < Xus.  (i.e. --search 95:1000 means find the QPS where 95% of requests are faster than 1000us). help description.  *\/$/;"	m	struct:gengetopt_args_info
search_orig	cmdline.h	/^  char * search_orig;	\/**< @brief Search for the QPS where N-order statistic < Xus.  (i.e. --search 95:1000 means find the QPS where 95% of requests are faster than 1000us). original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
sent_seq	dpdktcp.c	/^	uint32_t sent_seq;$/;"	m	struct:pcb	file:
sent_seq	dpdktcp.c	/^	uint32_t sent_seq;$/;"	m	struct:tcp_hdr	file:
seq_no	binary_protocol.h	/^  uint16_t seq_no;$/;"	m	struct:__anon3
server_arg	cmdline.h	/^  char ** server_arg;	\/**< @brief Memcached server hostname[:port].  Repeat to specify multiple servers..  *\/$/;"	m	struct:gengetopt_args_info
server_given	ConnectionOptions.h	/^  int server_given;$/;"	m	struct:__anon9
server_given	cmdline.h	/^  unsigned int server_given ;	\/**< @brief Whether server was given.  *\/$/;"	m	struct:gengetopt_args_info
server_help	cmdline.h	/^  const char *server_help; \/**< @brief Memcached server hostname[:port].  Repeat to specify multiple servers. help description.  *\/$/;"	m	struct:gengetopt_args_info
server_mac_arg	cmdline.h	/^  char * server_mac_arg;	\/**< @brief The MAC address of the server..  *\/$/;"	m	struct:gengetopt_args_info
server_mac_given	cmdline.h	/^  unsigned int server_mac_given ;	\/**< @brief Whether server-mac was given.  *\/$/;"	m	struct:gengetopt_args_info
server_mac_help	cmdline.h	/^  const char *server_mac_help; \/**< @brief The MAC address of the server. help description.  *\/$/;"	m	struct:gengetopt_args_info
server_mac_orig	cmdline.h	/^  char * server_mac_orig;	\/**< @brief The MAC address of the server. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
server_max	cmdline.h	/^  unsigned int server_max; \/**< @brief Memcached server hostname[:port].  Repeat to specify multiple servers.'s maximum occurreces *\/$/;"	m	struct:gengetopt_args_info
server_min	cmdline.h	/^  unsigned int server_min; \/**< @brief Memcached server hostname[:port].  Repeat to specify multiple servers.'s minimum occurreces *\/$/;"	m	struct:gengetopt_args_info
server_orig	cmdline.h	/^  char ** server_orig;	\/**< @brief Memcached server hostname[:port].  Repeat to specify multiple servers. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
servers	mutilate.cc	/^  const vector<string> *servers;$/;"	m	struct:thread_data	file:
servers	mutilatedpdk.cc	/^static vector<string> servers;$/;"	v	file:
servers	mutilateudp.cc	/^static vector<string> servers;$/;"	v	file:
set_lambda	Generator.h	/^  virtual void set_lambda(double lambda) { this->lambda = lambda; }$/;"	f	class:Exponential
set_lambda	Generator.h	/^  virtual void set_lambda(double lambda) {$/;"	f	class:Fixed
set_lambda	Generator.h	/^  virtual void set_lambda(double lambda) {$/;"	f	class:GPareto
set_lambda	Generator.h	/^  virtual void set_lambda(double lambda) {$/;"	f	class:Normal
set_lambda	Generator.h	/^  virtual void set_lambda(double lambda) {$/;"	f	class:Uniform
set_lambda	Generator.h	/^  virtual void set_lambda(double lambda) {DIE("set_lambda() not implemented");}$/;"	f	class:Generator
set_priority	TCPConnection.cc	/^void TCPConnection::set_priority(int pri) {$/;"	f	class:TCPConnection
set_sampler	ConnectionStats.h	/^  AdaptiveSampler<Operation> set_sampler;$/;"	m	class:ConnectionStats
set_sampler	ConnectionStats.h	/^  HistogramSampler set_sampler;$/;"	m	class:ConnectionStats
set_sampler	ConnectionStats.h	/^  LogHistogramSampler set_sampler;$/;"	m	class:ConnectionStats
sets	AgentStats.h	/^  uint64_t gets, sets, get_misses;$/;"	m	class:AgentStats
sets	ConnectionStats.h	/^  uint64_t gets, sets, get_misses;$/;"	m	class:ConnectionStats
shape	Generator.h	/^  double loc \/* mu *\/, scale \/* sigma *\/, shape \/* k *\/;$/;"	m	class:GEV
shape	Generator.h	/^  double scale \/* sigma *\/, shape \/* k *\/;$/;"	m	class:GPareto
shell	mutilate_merge_logs.py	/^def shell(cmd):$/;"	f
should_sample	ConnectionOptions.h	/^  bool should_sample;$/;"	m	struct:__anon9
sigma	Generator.h	/^  double mu, sigma;$/;"	m	class:LogNormal
sin_noise	ConnectionOptions.h	/^    struct qps_function_sin_noise sin_noise;$/;"	m	union:qps_function_info::__anon8	typeref:struct:qps_function_info::__anon8::qps_function_sin_noise
sin_noise	common.cc	/^static int sin_noise(struct qps_function_sin_noise *p, double t) {$/;"	f	file:
size	UDPConnection.cc	/^size_t OpQueue::size()$/;"	f	class:OpQueue
skip	ConnectionOptions.h	/^  bool skip;$/;"	m	struct:__anon9
skip_given	cmdline.h	/^  unsigned int skip_given ;	\/**< @brief Whether skip was given.  *\/$/;"	m	struct:gengetopt_args_info
skip_help	cmdline.h	/^  const char *skip_help; \/**< @brief Skip transmissions if previous requests are late.  This harms the long-term QPS average, but reduces spikes in QPS after long latency requests. help description.  *\/$/;"	m	struct:gengetopt_args_info
skips	AgentStats.h	/^  uint64_t skips;$/;"	m	class:AgentStats
skips	ConnectionStats.h	/^  uint64_t skips;$/;"	m	class:ConnectionStats
sleep_time	util.cc	/^void sleep_time(double duration) {$/;"	f
socket	common.h	/^  zmq::socket_t *socket;$/;"	m	struct:agent_stats_thread_data
socket	mutilate.cc	/^  zmq::socket_t *socket;$/;"	m	struct:thread_data	file:
src_addr	dpdktcp.c	/^	uint32_t src_addr;$/;"	m	struct:ipv4_hdr	file:
src_port	TCPConnection.h	/^  int src_port;$/;"	m	class:TCPConnection
src_port	dpdktcp.c	/^	uint16_t src_port;$/;"	m	struct:tcp_hdr	file:
src_port_arg	cmdline.h	/^  char ** src_port_arg;	\/**< @brief A list of IP source ports to use in order to achieve desired RSS queue distribution..  *\/$/;"	m	struct:gengetopt_args_info
src_port_given	cmdline.h	/^  unsigned int src_port_given ;	\/**< @brief Whether src-port was given.  *\/$/;"	m	struct:gengetopt_args_info
src_port_help	cmdline.h	/^  const char *src_port_help; \/**< @brief A list of IP source ports to use in order to achieve desired RSS queue distribution. help description.  *\/$/;"	m	struct:gengetopt_args_info
src_port_max	cmdline.h	/^  unsigned int src_port_max; \/**< @brief A list of IP source ports to use in order to achieve desired RSS queue distribution.'s maximum occurreces *\/$/;"	m	struct:gengetopt_args_info
src_port_min	cmdline.h	/^  unsigned int src_port_min; \/**< @brief A list of IP source ports to use in order to achieve desired RSS queue distribution.'s minimum occurreces *\/$/;"	m	struct:gengetopt_args_info
src_port_orig	cmdline.h	/^  char ** src_port_orig;	\/**< @brief A list of IP source ports to use in order to achieve desired RSS queue distribution. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
src_ports	mutilate.cc	/^  vector<int> src_ports;$/;"	m	struct:thread_data	file:
start	AgentStats.h	/^  double start, stop;$/;"	m	class:AgentStats
start	ConnectionStats.h	/^  double start, stop;$/;"	m	class:ConnectionStats
start0	common.h	/^  int start0;$/;"	m	struct:scan_search_params_struct
start2	common.h	/^  int start2;$/;"	m	struct:scan_search_ctx
start_connections	mutilatedpdk.cc	/^static void start_connections(vector<DPDKConnection *> *connections)$/;"	f	file:
start_connections	mutilateudp.cc	/^static void start_connections(vector<UDPConnection *> *connections)$/;"	f	file:
start_loading	TCPConnection.cc	/^void TCPConnection::start_loading() {$/;"	f	class:TCPConnection
start_time	Operation.h	/^  double start_time, end_time;$/;"	m	class:Operation
start_time	TCPConnection.h	/^  double start_time;  \/\/ Time when this connection began operations.$/;"	m	class:TCPConnection
start_time	common.cc	/^  double start_time;$/;"	m	struct:__anon4	file:
start_time1	common.h	/^  double start_time1;$/;"	m	struct:scan_search_ctx
start_time2	common.h	/^  double start_time2;$/;"	m	struct:scan_search_ctx
state	dpdktcp.c	/^	} state;$/;"	m	struct:pcb	typeref:enum:pcb::__anon7	file:
stats	Connection.h	/^  ConnectionStats stats;$/;"	m	class:Connection
status	binary_protocol.h	/^   uint16_t status;  \/\/ response use$/;"	m	union:__anon1::__anon2
stddev	LogHistogramSampler.h	/^  double stddev() {$/;"	f	class:LogHistogramSampler
step	ConnectionOptions.h	/^  int step;$/;"	m	struct:qps_function_qtriangle
step	common.h	/^  int step;$/;"	m	struct:scan_search_ctx
step0	common.h	/^  int step0;$/;"	m	struct:scan_search_params_struct
step1	common.h	/^  int step1;$/;"	m	struct:scan_search_params_struct
step2	common.h	/^  int step2;$/;"	m	struct:scan_search_params_struct
stop	AgentStats.h	/^  double start, stop;$/;"	m	class:AgentStats
stop	ConnectionStats.h	/^  double start, stop;$/;"	m	class:ConnectionStats
stop0	common.h	/^  int stop0;$/;"	m	struct:scan_search_params_struct
stop_latency_arg	cmdline.h	/^  char * stop_latency_arg;	\/**< @brief Stop scanning when N-order statistic > Xus.  (i.e. --stop-latency 95:1000 means stop scanning when 95% of requests are slower than 1000us)..  *\/$/;"	m	struct:gengetopt_args_info
stop_latency_given	cmdline.h	/^  unsigned int stop_latency_given ;	\/**< @brief Whether stop-latency was given.  *\/$/;"	m	struct:gengetopt_args_info
stop_latency_help	cmdline.h	/^  const char *stop_latency_help; \/**< @brief Stop scanning when N-order statistic > Xus.  (i.e. --stop-latency 95:1000 means stop scanning when 95% of requests are slower than 1000us). help description.  *\/$/;"	m	struct:gengetopt_args_info
stop_latency_orig	cmdline.h	/^  char * stop_latency_orig;	\/**< @brief Stop scanning when N-order statistic > Xus.  (i.e. --stop-latency 95:1000 means stop scanning when 95% of requests are slower than 1000us). original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
string_arg	cmdline.cc	/^    char *string_arg;$/;"	m	union:generic_value	file:
string_arg	cmdline.cc	/^  char * string_arg;$/;"	m	struct:line_list	file:
substract	ConnectionStats.h	/^  void substract(const ConnectionStats &cs) {$/;"	f	class:ConnectionStats
substract	LogHistogramSampler.h	/^  void substract(const LogHistogramSampler &h) {$/;"	f	class:LogHistogramSampler
sum	LogHistogramSampler.h	/^  double sum;$/;"	m	class:LogHistogramSampler
sum_sq	LogHistogramSampler.h	/^  double sum_sq;$/;"	m	class:LogHistogramSampler
sync_agent	common.cc	/^void sync_agent(zmq::socket_t* socket) {$/;"	f
tcp_cksum	dpdktcp.c	/^static uint16_t tcp_cksum(struct ipv4_hdr *ipv4_hdr, struct tcp_hdr *tcp_hdr, const char *payload, size_t len)$/;"	f	file:
tcp_connect	dpdktcp.c	/^void tcp_connect(struct pcb *pcb, const struct rte_ether_addr *mac, uint32_t ip, uint16_t port)$/;"	f
tcp_create	dpdktcp.c	/^struct pcb *tcp_create(void *arg)$/;"	f
tcp_flags	dpdktcp.c	/^	uint8_t tcp_flags;$/;"	m	struct:tcp_hdr	file:
tcp_hdr	dpdktcp.c	/^struct tcp_hdr {$/;"	s	file:
tcp_init	dpdktcp.c	/^void tcp_init(void)$/;"	f
tcp_input	dpdktcp.c	/^static void tcp_input(struct rte_mbuf *mbuf)$/;"	f	file:
tcp_send	dpdktcp.c	/^void tcp_send(struct pcb *pcb, const void *data, size_t len)$/;"	f
tcp_urp	dpdktcp.c	/^	uint16_t tcp_urp;$/;"	m	struct:tcp_hdr	file:
theta	Generator.h	/^  double theta;$/;"	m	class:Zipf
thread_data	mutilate.cc	/^struct thread_data {$/;"	s	file:
thread_main	mutilate.cc	/^void* thread_main(void *arg) {$/;"	f
threads	ConnectionOptions.h	/^  int threads;$/;"	m	struct:__anon9
threads_arg	cmdline.h	/^  int threads_arg;	\/**< @brief Number of threads to spawn. (default='1').  *\/$/;"	m	struct:gengetopt_args_info
threads_given	cmdline.h	/^  unsigned int threads_given ;	\/**< @brief Whether threads was given.  *\/$/;"	m	struct:gengetopt_args_info
threads_help	cmdline.h	/^  const char *threads_help; \/**< @brief Number of threads to spawn. help description.  *\/$/;"	m	struct:gengetopt_args_info
threads_orig	cmdline.h	/^  char * threads_orig;	\/**< @brief Number of threads to spawn. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
time	ConnectionOptions.h	/^  int time;$/;"	m	struct:__anon9
time	Operation.h	/^  double time() const { return (end_time - start_time) * 1000000; }$/;"	f	class:Operation
time_arg	cmdline.h	/^  int time_arg;	\/**< @brief Maximum time to run (seconds). (default='5').  *\/$/;"	m	struct:gengetopt_args_info
time_given	cmdline.h	/^  unsigned int time_given ;	\/**< @brief Whether time was given.  *\/$/;"	m	struct:gengetopt_args_info
time_help	cmdline.h	/^  const char *time_help; \/**< @brief Maximum time to run (seconds). help description.  *\/$/;"	m	struct:gengetopt_args_info
time_orig	cmdline.h	/^  char * time_orig;	\/**< @brief Maximum time to run (seconds). original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
timer	DPDKConnection.h	/^	struct rte_timer timer;$/;"	m	class:DPDKConnection	typeref:struct:DPDKConnection::rte_timer
timer	TCPConnection.h	/^  struct event *timer;  \/\/ Used to control inter-transmission time.$/;"	m	class:TCPConnection	typeref:struct:TCPConnection::event
timer	UDPConnection.h	/^	struct event *timer;$/;"	m	class:UDPConnection	typeref:struct:UDPConnection::event
timer_callback	DPDKConnection.cc	/^void DPDKConnection::timer_callback()$/;"	f	class:DPDKConnection
timer_callback	TCPConnection.cc	/^void TCPConnection::timer_callback() { drive_write_machine(); }$/;"	f	class:TCPConnection
timer_callback	UDPConnection.cc	/^void UDPConnection::timer_callback()$/;"	f	class:UDPConnection
timer_cb	DPDKConnection.cc	/^void timer_cb(struct rte_timer *tim, void *arg)$/;"	f
timer_cb	TCPConnection.cc	/^void timer_cb(evutil_socket_t fd, short what, void *ptr) {$/;"	f
timer_cb	UDPConnection.cc	/^void timer_cb(evutil_socket_t fd, short what, void *ptr)$/;"	f
tos	dpdktcp.c	/^	uint8_t tos;$/;"	m	struct:ipv4_hdr	file:
total	HistogramSampler.h	/^  uint64_t total() {$/;"	f	class:HistogramSampler
total	LogHistogramSampler.h	/^  uint64_t total() {$/;"	f	class:LogHistogramSampler
total_samples	AdaptiveSampler.h	/^  unsigned int total_samples;$/;"	m	class:AdaptiveSampler
triangle	ConnectionOptions.h	/^    struct qps_function_triangle triangle;$/;"	m	union:qps_function_info::__anon8	typeref:struct:qps_function_info::__anon8::qps_function_triangle
triangle	ConnectionOptions.h	/^  struct qps_function_triangle triangle;$/;"	m	struct:qps_function_qtriangle	typeref:struct:qps_function_qtriangle::qps_function_triangle
triangle	common.cc	/^static int triangle(struct qps_function_triangle *p, double t) {$/;"	f	file:
ttl	dpdktcp.c	/^	uint8_t ttl;$/;"	m	struct:ipv4_hdr	file:
tv_to_double	util.h	/^inline double tv_to_double(struct timeval *tv) {$/;"	f
tx_bytes	AgentStats.h	/^  uint64_t rx_bytes, tx_bytes;$/;"	m	class:AgentStats
tx_bytes	ConnectionStats.h	/^  uint64_t rx_bytes, tx_bytes;$/;"	m	class:ConnectionStats
tx_prep	dpdktcp.c	/^static struct rte_mbuf *tx_prep(const struct pcb *pcb, size_t payload_len)$/;"	f	file:
tx_tcp_flags	dpdktcp.c	/^static void tx_tcp_flags(struct pcb *pcb, uint8_t tcp_flags)$/;"	f	file:
type	ConnectionOptions.h	/^  enum qps_function_type type;$/;"	m	struct:qps_function_info	typeref:enum:qps_function_info::qps_function_type
type	Generator.h	/^  std::string type;$/;"	m	class:Generator
type	Operation.h	/^  type_enum type;$/;"	m	class:Operation
type	common.h	/^  enum type {$/;"	g	struct:agent_stats_msg
type	common.h	/^  } type;$/;"	m	struct:agent_stats_msg	typeref:enum:agent_stats_msg::type
type_enum	Operation.h	/^  enum type_enum {$/;"	g	class:Operation
udp_header_t	binary_protocol.h	/^} udp_header_t;$/;"	t	typeref:struct:__anon3
unlikely	TCPConnection.cc	664;"	d	file:
update	ConnectionOptions.h	/^  double update;$/;"	m	struct:__anon9
update_arg	cmdline.cc	/^int update_arg(void *field, char **orig_field,$/;"	f	file:
update_arg	cmdline.h	/^  float update_arg;	\/**< @brief Ratio of set:get commands. (default='0.0').  *\/$/;"	m	struct:gengetopt_args_info
update_given	cmdline.h	/^  unsigned int update_given ;	\/**< @brief Whether update was given.  *\/$/;"	m	struct:gengetopt_args_info
update_help	cmdline.h	/^  const char *update_help; \/**< @brief Ratio of set:get commands. help description.  *\/$/;"	m	struct:gengetopt_args_info
update_multiple_arg	cmdline.cc	/^void update_multiple_arg(void *field, char ***orig_field,$/;"	f	file:
update_multiple_arg_temp	cmdline.cc	/^int update_multiple_arg_temp(struct generic_list **list,$/;"	f	file:
update_orig	cmdline.h	/^  char * update_orig;	\/**< @brief Ratio of set:get commands. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
username	ConnectionOptions.h	/^  char username[32];$/;"	m	struct:__anon9
username_arg	cmdline.h	/^  char * username_arg;	\/**< @brief Username to use for SASL authentication..  *\/$/;"	m	struct:gengetopt_args_info
username_given	cmdline.h	/^  unsigned int username_given ;	\/**< @brief Whether username was given.  *\/$/;"	m	struct:gengetopt_args_info
username_help	cmdline.h	/^  const char *username_help; \/**< @brief Username to use for SASL authentication. help description.  *\/$/;"	m	struct:gengetopt_args_info
username_orig	cmdline.h	/^  char * username_orig;	\/**< @brief Username to use for SASL authentication. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
v1	Generator.h	/^  double ratio, v1, v2;$/;"	m	class:Bimodal
v2	Generator.h	/^  double ratio, v1, v2;$/;"	m	class:Bimodal
val	common.h	/^  int val;$/;"	m	struct:scan_search_params_struct
val_size	Generator.h	/^    Generator* val_size;$/;"	m	class:CustomKeyGenerator
value	Generator.h	/^  double value;$/;"	m	class:Fixed
value_size	Operation.h	/^  uint64_t value_size;$/;"	m	class:Operation
valuesize	ConnectionOptions.h	/^  char valuesize[32];$/;"	m	struct:__anon9
valuesize	DPDKConnection.h	/^	Generator *valuesize;$/;"	m	class:DPDKConnection
valuesize	TCPConnection.h	/^  Generator *valuesize;$/;"	m	class:TCPConnection
valuesize_arg	cmdline.h	/^  char * valuesize_arg;	\/**< @brief Length of memcached values (distribution). (default='200').  *\/$/;"	m	struct:gengetopt_args_info
valuesize_given	cmdline.h	/^  unsigned int valuesize_given ;	\/**< @brief Whether valuesize was given.  *\/$/;"	m	struct:gengetopt_args_info
valuesize_help	cmdline.h	/^  const char *valuesize_help; \/**< @brief Length of memcached values (distribution). help description.  *\/$/;"	m	struct:gengetopt_args_info
valuesize_orig	cmdline.h	/^  char * valuesize_orig;	\/**< @brief Length of memcached values (distribution). original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
vbucket	binary_protocol.h	/^   uint16_t vbucket; \/\/ request use$/;"	m	union:__anon1::__anon2
verbose_given	cmdline.h	/^  unsigned int verbose_given ;	\/**< @brief Whether verbose was given.  *\/$/;"	m	struct:gengetopt_args_info
verbose_help	cmdline.h	/^  const char *verbose_help; \/**< @brief Verbosity. Repeat for more verbose. help description.  *\/$/;"	m	struct:gengetopt_args_info
verbose_max	cmdline.h	/^  unsigned int verbose_max; \/**< @brief Verbosity. Repeat for more verbose.'s maximum occurreces *\/$/;"	m	struct:gengetopt_args_info
verbose_min	cmdline.h	/^  unsigned int verbose_min; \/**< @brief Verbosity. Repeat for more verbose.'s minimum occurreces *\/$/;"	m	struct:gengetopt_args_info
version	binary_protocol.h	/^  uint64_t version;$/;"	m	struct:__anon1
version	dpdktcp.c	/^	uint8_t header_len: 4, version: 4;$/;"	m	struct:ipv4_hdr	file:
version_given	cmdline.h	/^  unsigned int version_given ;	\/**< @brief Whether version was given.  *\/$/;"	m	struct:gengetopt_args_info
version_help	cmdline.h	/^  const char *version_help; \/**< @brief Print version and exit help description.  *\/$/;"	m	struct:gengetopt_args_info
wait_arg	cmdline.h	/^  int wait_arg;	\/**< @brief Time to wait after startup to start measurement..  *\/$/;"	m	struct:gengetopt_args_info
wait_given	cmdline.h	/^  unsigned int wait_given ;	\/**< @brief Whether wait was given.  *\/$/;"	m	struct:gengetopt_args_info
wait_help	cmdline.h	/^  const char *wait_help; \/**< @brief Time to wait after startup to start measurement. help description.  *\/$/;"	m	struct:gengetopt_args_info
wait_orig	cmdline.h	/^  char * wait_orig;	\/**< @brief Time to wait after startup to start measurement. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
warmup	ConnectionOptions.h	/^  int warmup;$/;"	m	struct:__anon9
warmup_arg	cmdline.h	/^  int warmup_arg;	\/**< @brief Warmup time before starting measurement..  *\/$/;"	m	struct:gengetopt_args_info
warmup_given	cmdline.h	/^  unsigned int warmup_given ;	\/**< @brief Whether warmup was given.  *\/$/;"	m	struct:gengetopt_args_info
warmup_help	cmdline.h	/^  const char *warmup_help; \/**< @brief Warmup time before starting measurement. help description.  *\/$/;"	m	struct:gengetopt_args_info
warmup_orig	cmdline.h	/^  char * warmup_orig;	\/**< @brief Warmup time before starting measurement. original value given at command line.  *\/$/;"	m	struct:gengetopt_args_info
warmup_rate	ConnectionOptions.h	/^  int warmup_rate;$/;"	m	struct:qps_function_info
warmup_time	ConnectionOptions.h	/^  int warmup_time;$/;"	m	struct:qps_function_info
width	HistogramSampler.h	/^  int width;$/;"	m	class:HistogramSampler
write_callback	TCPConnection.cc	/^void TCPConnection::write_callback() {}$/;"	f	class:TCPConnection
write_into_file	cmdline.cc	/^write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])$/;"	f	file:
write_multiple_into_file	cmdline.cc	/^write_multiple_into_file(FILE *outfile, int len, const char *opt, char **arg, const char *values[])$/;"	f	file:
write_state	DPDKConnection.h	/^	enum write_state_enum write_state;$/;"	m	class:DPDKConnection	typeref:enum:DPDKConnection::write_state_enum
write_state	TCPConnection.h	/^  write_state_enum write_state;$/;"	m	class:TCPConnection
write_state	UDPConnection.h	/^	enum write_state_enum write_state;$/;"	m	class:UDPConnection	typeref:enum:UDPConnection::write_state_enum
write_state_enum	Connection.h	/^  enum write_state_enum {$/;"	g	class:Connection
zeta	Generator.h	/^  double zeta(int n, double theta) {$/;"	f	class:Zipf
zetan	Generator.h	/^  double zetan;$/;"	m	class:Zipf
~Discrete	Generator.h	/^  ~Discrete() { delete def; }$/;"	f	class:Discrete
~Generator	Generator.h	/^  virtual ~Generator() {}$/;"	f	class:Generator
~TCPConnection	TCPConnection.cc	/^TCPConnection::~TCPConnection() {$/;"	f	class:TCPConnection
~Zipf	Generator.h	/^  ~Zipf() {$/;"	f	class:Zipf
